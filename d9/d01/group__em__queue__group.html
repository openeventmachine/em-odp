<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EM-ODP: Queue group</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doc-stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EM-ODP
   &#160;<span id="projectnumber">3.8.0-1</span>
   </div>
   <div id="projectbrief">Event Machine on ODP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d9/d01/group__em__queue__group.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Queue group</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5660d6d2ae52d46a31a3de832a32be5d"><td class="memItemLeft" align="right" valign="top">em_queue_group_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d01/group__em__queue__group.html#ga5660d6d2ae52d46a31a3de832a32be5d">em_queue_group_create</a> (const char *name, const <a class="el" href="../../df/d81/structem__core__mask__t.html">em_core_mask_t</a> *mask, int num_notif, const <a class="el" href="../../d8/db3/structem__notif__t.html">em_notif_t</a> notif_tbl[])</td></tr>
<tr class="separator:ga5660d6d2ae52d46a31a3de832a32be5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f3e8e31f260f65abc902aad59c4497d"><td class="memItemLeft" align="right" valign="top">em_queue_group_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d01/group__em__queue__group.html#ga6f3e8e31f260f65abc902aad59c4497d">em_queue_group_create_sync</a> (const char *name, const <a class="el" href="../../df/d81/structem__core__mask__t.html">em_core_mask_t</a> *mask)</td></tr>
<tr class="separator:ga6f3e8e31f260f65abc902aad59c4497d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0231c3fa0532cd4b9d8ebada73c394e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d01/group__em__queue__group.html#gaa0231c3fa0532cd4b9d8ebada73c394e">em_queue_group_delete</a> (em_queue_group_t queue_group, int num_notif, const <a class="el" href="../../d8/db3/structem__notif__t.html">em_notif_t</a> notif_tbl[])</td></tr>
<tr class="separator:gaa0231c3fa0532cd4b9d8ebada73c394e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8365f2f58ef1a18dbed608422dcf2ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d01/group__em__queue__group.html#ga8365f2f58ef1a18dbed608422dcf2ae7">em_queue_group_delete_sync</a> (em_queue_group_t queue_group)</td></tr>
<tr class="separator:ga8365f2f58ef1a18dbed608422dcf2ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga59e3b34707a34f9be634f7b66c25a876"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d01/group__em__queue__group.html#ga59e3b34707a34f9be634f7b66c25a876">em_queue_group_modify</a> (em_queue_group_t queue_group, const <a class="el" href="../../df/d81/structem__core__mask__t.html">em_core_mask_t</a> *new_mask, int num_notif, const <a class="el" href="../../d8/db3/structem__notif__t.html">em_notif_t</a> notif_tbl[])</td></tr>
<tr class="separator:ga59e3b34707a34f9be634f7b66c25a876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45edcc37b6f62912ff4a8a11ae803a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d01/group__em__queue__group.html#ga45edcc37b6f62912ff4a8a11ae803a99">em_queue_group_modify_sync</a> (em_queue_group_t queue_group, const <a class="el" href="../../df/d81/structem__core__mask__t.html">em_core_mask_t</a> *new_mask)</td></tr>
<tr class="separator:ga45edcc37b6f62912ff4a8a11ae803a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17b2712720cfb7a5875ad21deb39b565"><td class="memItemLeft" align="right" valign="top">em_queue_group_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d01/group__em__queue__group.html#ga17b2712720cfb7a5875ad21deb39b565">em_queue_group_find</a> (const char *name)</td></tr>
<tr class="separator:ga17b2712720cfb7a5875ad21deb39b565"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a861d268d820d2b6de1341749b4011a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d01/group__em__queue__group.html#ga0a861d268d820d2b6de1341749b4011a">em_queue_group_get_mask</a> (em_queue_group_t queue_group, <a class="el" href="../../df/d81/structem__core__mask__t.html">em_core_mask_t</a> *mask)</td></tr>
<tr class="separator:ga0a861d268d820d2b6de1341749b4011a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aae6ca34627557ab668dc2bb6c54ebc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d01/group__em__queue__group.html#ga8aae6ca34627557ab668dc2bb6c54ebc">em_queue_group_get_name</a> (em_queue_group_t queue_group, char *name, size_t maxlen)</td></tr>
<tr class="separator:ga8aae6ca34627557ab668dc2bb6c54ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93115ce0cf2963147f75857621f39b2e"><td class="memItemLeft" align="right" valign="top">em_queue_group_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d01/group__em__queue__group.html#ga93115ce0cf2963147f75857621f39b2e">em_queue_group_get_first</a> (unsigned int *num)</td></tr>
<tr class="separator:ga93115ce0cf2963147f75857621f39b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef56bcc67ade1bbb4406c44a9a6d4f0c"><td class="memItemLeft" align="right" valign="top">em_queue_group_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d01/group__em__queue__group.html#gaef56bcc67ade1bbb4406c44a9a6d4f0c">em_queue_group_get_next</a> (void)</td></tr>
<tr class="separator:gaef56bcc67ade1bbb4406c44a9a6d4f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga184240ab56df837903d8494b0b3c180a"><td class="memItemLeft" align="right" valign="top">em_queue_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d01/group__em__queue__group.html#ga184240ab56df837903d8494b0b3c180a">em_queue_group_queue_get_first</a> (unsigned int *num, em_queue_group_t queue_group)</td></tr>
<tr class="separator:ga184240ab56df837903d8494b0b3c180a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaf6fab7440b8211aee5714c31ac52e0"><td class="memItemLeft" align="right" valign="top">em_queue_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d01/group__em__queue__group.html#gaaaf6fab7440b8211aee5714c31ac52e0">em_queue_group_queue_get_next</a> (void)</td></tr>
<tr class="separator:gaaaf6fab7440b8211aee5714c31ac52e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabaa122dd3a9403094d693a8b2a6e2c82"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d01/group__em__queue__group.html#gabaa122dd3a9403094d693a8b2a6e2c82">em_queue_group_to_u64</a> (em_queue_group_t queue_group)</td></tr>
<tr class="separator:gabaa122dd3a9403094d693a8b2a6e2c82"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Operations on queue groups</p>
<p>A queue group is basically a set of cores (threads) within an EM instance allowed to receive events from a queue belonging to that queue group. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5660d6d2ae52d46a31a3de832a32be5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5660d6d2ae52d46a31a3de832a32be5d">&#9670;&nbsp;</a></span>em_queue_group_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_queue_group_t em_queue_group_create </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d81/structem__core__mask__t.html">em_core_mask_t</a> *&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_notif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/db3/structem__notif__t.html">em_notif_t</a>&#160;</td>
          <td class="paramname"><em>notif_tbl</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new queue group to control queue to core mapping, asynchronous (non-blocking)</p>
<p>Allocates a new queue group handle with a given core mask. Cores added to the queue group can be changed later with <a class="el" href="../../d9/d01/group__em__queue__group.html#ga59e3b34707a34f9be634f7b66c25a876">em_queue_group_modify()</a>.</p>
<p>This operation may be asynchronous, i.e. the creation may complete well after this function has returned. Provide notification events, if the application needs to know about the actual completion. EM will send notifications when the operation has completed. Note that using a queue group before the creation has completed may result in undefined behaviour.</p>
<p>The core mask is visible through <a class="el" href="../../d9/d01/group__em__queue__group.html#ga0a861d268d820d2b6de1341749b4011a">em_queue_group_get_mask()</a> only after the create operation has completed.</p>
<p>Note, that the operation can also happen one core at a time, so an intermediate mask may be active momentarily.</p>
<p>Only manipulate the core mask with the access macros defined in <a class="el" href="../../d3/d7b/event__machine__hw__specific_8h.html">event_machine_hw_specific.h</a> as the implementation underneath may change.</p>
<p>The given name is copied up to the maximum length of EM_QUEUE_GROUP_NAME_LEN. Duplicate names are allowed, but find will then only return the first match. The name "default" is reserved for EM_QUEUE_GROUP_DEFAULT.</p>
<p>EM has a default group EM_QUEUE_GROUP_DEFAULT containing all cores running this EM instance. It's named "default".</p>
<p>Some systems may have a low number of queue groups available.</p>
<dl class="section attention"><dt>Attention</dt><dd>Only call <a class="el" href="../../de/d3c/group__em__queue.html#gaef257858d1fa660524f198dba20fa9eb">em_queue_create()</a> after <a class="el" href="../../d9/d01/group__em__queue__group.html#ga5660d6d2ae52d46a31a3de832a32be5d">em_queue_group_create()</a> has completed - use notifications to synchronize. Alternatively use <a class="el" href="../../d9/d01/group__em__queue__group.html#ga6f3e8e31f260f65abc902aad59c4497d">em_queue_group_create_sync()</a> to be able to create the queue directly after creating the queue group in the source code.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Queue group name (optional, NULL ok) </td></tr>
    <tr><td class="paramname">mask</td><td>Core mask for the queue group </td></tr>
    <tr><td class="paramname">num_notif</td><td>Number of entries in notif_tbl (use 0 for no notification) </td></tr>
    <tr><td class="paramname">notif_tbl</td><td>Array of notifications to send as the operation completes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Queue group or EM_QUEUE_GROUP_UNDEF on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d01/group__em__queue__group.html#ga17b2712720cfb7a5875ad21deb39b565">em_queue_group_find()</a>, <a class="el" href="../../d9/d01/group__em__queue__group.html#ga59e3b34707a34f9be634f7b66c25a876">em_queue_group_modify()</a>, <a class="el" href="../../d9/d01/group__em__queue__group.html#gaa0231c3fa0532cd4b9d8ebada73c394e">em_queue_group_delete()</a>, <a class="el" href="../../d9/d01/group__em__queue__group.html#ga6f3e8e31f260f65abc902aad59c4497d">em_queue_group_create_sync()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d8/dc3/queue_group_8c-example.html#a49">queue_group.c</a>, and <a class="el" href="../../d6/dd3/queue_groups_8c-example.html#a44">queue_groups.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html#l00040">40</a> of file <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html">event_machine_queue_group.c</a>.</p>

</div>
</div>
<a id="ga6f3e8e31f260f65abc902aad59c4497d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f3e8e31f260f65abc902aad59c4497d">&#9670;&nbsp;</a></span>em_queue_group_create_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_queue_group_t em_queue_group_create_sync </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d81/structem__core__mask__t.html">em_core_mask_t</a> *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new queue group to control queue to core mapping, synchronous (blocking).</p>
<p>As <a class="el" href="../../d9/d01/group__em__queue__group.html#ga5660d6d2ae52d46a31a3de832a32be5d">em_queue_group_create()</a>, but will not return until the operation is complete.</p>
<p>Note that the function is blocking and will not return until the operation has completed across all concerned EM cores. Sync-API calls can block the core for a long (indefinite) time, thus they should not be used to make runtime changes on real time EM cores - consider the async variants of the APIs in these cases instead. While one core is calling a sync-API function, the others must be running the EM dispatch loop to be able to receive and handle the sync-API request events sent internally. Use the sync-APIs mainly to simplify application start-up or teardown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Queue group name (optional, NULL ok) </td></tr>
    <tr><td class="paramname">mask</td><td>Core mask for the queue group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Queue group or EM_QUEUE_GROUP_UNDEF on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d01/group__em__queue__group.html#ga5660d6d2ae52d46a31a3de832a32be5d">em_queue_group_create()</a> for an asynchronous version of the API </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../dd/d3c/scheduling_latency_8c-example.html#a15">scheduling_latency.c</a>, and <a class="el" href="../../d5/d57/timer_test_periodic_8c-example.html#a42">timer_test_periodic.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html#l00076">76</a> of file <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html">event_machine_queue_group.c</a>.</p>

</div>
</div>
<a id="gaa0231c3fa0532cd4b9d8ebada73c394e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0231c3fa0532cd4b9d8ebada73c394e">&#9670;&nbsp;</a></span>em_queue_group_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_queue_group_delete </td>
          <td>(</td>
          <td class="paramtype">em_queue_group_t&#160;</td>
          <td class="paramname"><em>queue_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_notif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/db3/structem__notif__t.html">em_notif_t</a>&#160;</td>
          <td class="paramname"><em>notif_tbl</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete the queue group, asynchronous (non-blocking)</p>
<p>Removes all cores from the queue group and free's the handle for reuse. All queues in the queue group must be deleted with <a class="el" href="../../de/d3c/group__em__queue.html#ga2a28907b18b348cbb153431c35af5752">em_queue_delete()</a> before deleting the queue group.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_group</td><td>Queue group to delete </td></tr>
    <tr><td class="paramname">num_notif</td><td>Number of entries in notif_tbl (0 for no notification) </td></tr>
    <tr><td class="paramname">notif_tbl</td><td>Array of notifications to send as the operation completes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_OK if successful.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d01/group__em__queue__group.html#ga5660d6d2ae52d46a31a3de832a32be5d">em_queue_group_create()</a>, <a class="el" href="../../d9/d01/group__em__queue__group.html#ga59e3b34707a34f9be634f7b66c25a876">em_queue_group_modify()</a>, <a class="el" href="../../de/d3c/group__em__queue.html#ga2a28907b18b348cbb153431c35af5752">em_queue_delete()</a>, <a class="el" href="../../d9/d01/group__em__queue__group.html#ga8365f2f58ef1a18dbed608422dcf2ae7">em_queue_group_delete_sync()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d8/dc3/queue_group_8c-example.html#a51">queue_group.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html#l00104">104</a> of file <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html">event_machine_queue_group.c</a>.</p>

</div>
</div>
<a id="ga8365f2f58ef1a18dbed608422dcf2ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8365f2f58ef1a18dbed608422dcf2ae7">&#9670;&nbsp;</a></span>em_queue_group_delete_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_queue_group_delete_sync </td>
          <td>(</td>
          <td class="paramtype">em_queue_group_t&#160;</td>
          <td class="paramname"><em>queue_group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Delete the queue group, synchronous (blocking).</p>
<p>As <a class="el" href="../../d9/d01/group__em__queue__group.html#gaa0231c3fa0532cd4b9d8ebada73c394e">em_queue_group_delete()</a>, but will not return until the operation is complete.</p>
<p>Note that the function is blocking and will not return until the operation has completed across all concerned EM cores. Sync-API calls can block the core for a long (indefinite) time, thus they should not be used to make runtime changes on real time EM cores - consider the async variants of the APIs in these cases instead. While one core is calling a sync-API function, the others must be running the EM dispatch loop to be able to receive and handle the sync-API request events sent internally. Use the sync-APIs mainly to simplify application start-up or teardown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_group</td><td>Queue group to delete</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_OK if successful.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d01/group__em__queue__group.html#gaa0231c3fa0532cd4b9d8ebada73c394e">em_queue_group_delete()</a> for an asynchronous version of the API </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html#l00135">135</a> of file <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html">event_machine_queue_group.c</a>.</p>

</div>
</div>
<a id="ga17b2712720cfb7a5875ad21deb39b565"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga17b2712720cfb7a5875ad21deb39b565">&#9670;&nbsp;</a></span>em_queue_group_find()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_queue_group_t em_queue_group_find </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds a queue group by name.</p>
<p>Finds a queue group by the given name (exact match). An empty string will not match anything. The search is case sensitive. If there are duplicate names, this will return the first match only.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">name</td><td>Name of the queue qroup to find</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Queue group or EM_QUEUE_GROUP_UNDEF if not found</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d01/group__em__queue__group.html#ga5660d6d2ae52d46a31a3de832a32be5d">em_queue_group_create()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d8/dc3/queue_group_8c-example.html#a16">queue_group.c</a>, and <a class="el" href="../../d6/dd3/queue_groups_8c-example.html#a50">queue_groups.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html#l00236">236</a> of file <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html">event_machine_queue_group.c</a>.</p>

</div>
</div>
<a id="ga93115ce0cf2963147f75857621f39b2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93115ce0cf2963147f75857621f39b2e">&#9670;&nbsp;</a></span>em_queue_group_get_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_queue_group_t em_queue_group_get_first </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize queue group iteration and return the first queue group handle.</p>
<p>Can be used to initialize the iteration to retrieve all created queue groups for debugging or management purposes. Use <a class="el" href="../../d9/d01/group__em__queue__group.html#gaef56bcc67ade1bbb4406c44a9a6d4f0c">em_queue_group_get_next()</a> after this call until it returns EM_QUEUE_GROUP_UNDEF. A new call to <a class="el" href="../../d9/d01/group__em__queue__group.html#ga93115ce0cf2963147f75857621f39b2e">em_queue_group_get_first()</a> resets the iteration, which is maintained per core (thread). The operation should be completed in one go before returning from the EO's event receive function (or start/stop).</p>
<p>The number of queue groups (output arg 'num') may not match the amount of queue groups actually returned by iterating using <a class="el" href="../../d8/d4c/group__em__event__group.html#ga28b77c2acaf50d9559fa56609c8893a5">em_event_group_get_next()</a> if queue groups are added or removed in parallel by another core. The order of the returned queue group handles is undefined.</p>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num;</div>
<div class="line">em_queue_group_t qg = <a class="code" href="../../d9/d01/group__em__queue__group.html#ga93115ce0cf2963147f75857621f39b2e">em_queue_group_get_first</a>(&amp;num);</div>
<div class="line"><span class="keywordflow">while</span> (qg != <a class="code" href="../../d4/d11/event__machine__types_8h.html#a3f2bef96eaf8b2855699d6adee7758f4">EM_QUEUE_GROUP_UNDEF</a>) {</div>
<div class="line">   qg = <a class="code" href="../../d9/d01/group__em__queue__group.html#gaef56bcc67ade1bbb4406c44a9a6d4f0c">em_queue_group_get_next</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aevent__machine__types_8h_html_a3f2bef96eaf8b2855699d6adee7758f4"><div class="ttname"><a href="../../d4/d11/event__machine__types_8h.html#a3f2bef96eaf8b2855699d6adee7758f4">EM_QUEUE_GROUP_UNDEF</a></div><div class="ttdeci">#define EM_QUEUE_GROUP_UNDEF</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d11/event__machine__types_8h_source.html#l00127">event_machine_types.h:127</a></div></div>
<div class="ttc" id="agroup__em__queue__group_html_ga93115ce0cf2963147f75857621f39b2e"><div class="ttname"><a href="../../d9/d01/group__em__queue__group.html#ga93115ce0cf2963147f75857621f39b2e">em_queue_group_get_first</a></div><div class="ttdeci">em_queue_group_t em_queue_group_get_first(unsigned int *num)</div><div class="ttdef"><b>Definition:</b> <a href="../../d5/dd9/event__machine__queue__group_8c_source.html#l00333">event_machine_queue_group.c:333</a></div></div>
<div class="ttc" id="agroup__em__queue__group_html_gaef56bcc67ade1bbb4406c44a9a6d4f0c"><div class="ttname"><a href="../../d9/d01/group__em__queue__group.html#gaef56bcc67ade1bbb4406c44a9a6d4f0c">em_queue_group_get_next</a></div><div class="ttdeci">em_queue_group_t em_queue_group_get_next(void)</div><div class="ttdef"><b>Definition:</b> <a href="../../d5/dd9/event__machine__queue__group_8c_source.html#l00363">event_machine_queue_group.c:363</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num</td><td>Pointer to an unsigned int to store the amount of queue groups into </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first queue group handle or EM_QUEUE_GROUP_UNDEF if none exist</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d01/group__em__queue__group.html#gaef56bcc67ade1bbb4406c44a9a6d4f0c">em_queue_group_get_next()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html#l00333">333</a> of file <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html">event_machine_queue_group.c</a>.</p>

</div>
</div>
<a id="ga0a861d268d820d2b6de1341749b4011a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a861d268d820d2b6de1341749b4011a">&#9670;&nbsp;</a></span>em_queue_group_get_mask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_queue_group_get_mask </td>
          <td>(</td>
          <td class="paramtype">em_queue_group_t&#160;</td>
          <td class="paramname"><em>queue_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d81/structem__core__mask__t.html">em_core_mask_t</a> *&#160;</td>
          <td class="paramname"><em>mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current core mask for a queue group.</p>
<p>This returns the situation at the moment of the inquiry. The result may not be up-to-date if another core is modifying the queue group at the same time. The application may need to synchronize group modifications.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_group</td><td>Queue group </td></tr>
    <tr><td class="paramname">mask</td><td>Core mask for the queue group</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_OK if successful.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d01/group__em__queue__group.html#ga5660d6d2ae52d46a31a3de832a32be5d">em_queue_group_create()</a>, <a class="el" href="../../d9/d01/group__em__queue__group.html#ga59e3b34707a34f9be634f7b66c25a876">em_queue_group_modify()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d8/dc3/queue_group_8c-example.html#a62">queue_group.c</a>, and <a class="el" href="../../d5/d57/timer_test_periodic_8c-example.html#a40">timer_test_periodic.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html#l00260">260</a> of file <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html">event_machine_queue_group.c</a>.</p>

</div>
</div>
<a id="ga8aae6ca34627557ab668dc2bb6c54ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8aae6ca34627557ab668dc2bb6c54ebc">&#9670;&nbsp;</a></span>em_queue_group_get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t em_queue_group_get_name </td>
          <td>(</td>
          <td class="paramtype">em_queue_group_t&#160;</td>
          <td class="paramname"><em>queue_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of a queue group.</p>
<p>A copy of the name string (up to 'maxlen' characters) is written to the user given buffer. The string is always null terminated, even if the given buffer length is less than the name length.</p>
<p>The function returns '0' and writes an empty string if the queue group has no name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">queue_group</td><td>Queue group id </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">name</td><td>Destination buffer </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">maxlen</td><td>Maximum length (including the terminating '\0')</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of characters written (excludes the terminating '\0'). </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d6/dd3/queue_groups_8c-example.html#a51">queue_groups.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html#l00288">288</a> of file <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html">event_machine_queue_group.c</a>.</p>

</div>
</div>
<a id="gaef56bcc67ade1bbb4406c44a9a6d4f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef56bcc67ade1bbb4406c44a9a6d4f0c">&#9670;&nbsp;</a></span>em_queue_group_get_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_queue_group_t em_queue_group_get_next </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Continues the queue group iteration started by <a class="el" href="../../d9/d01/group__em__queue__group.html#ga93115ce0cf2963147f75857621f39b2e">em_queue_group_get_first()</a> and returns the next queue group handle.</p>
<dl class="section return"><dt>Returns</dt><dd>The next queue group handle or EM_QUEUE_GROUP_UNDEF if the queue group iteration is completed (i.e. no more queue groups available).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d01/group__em__queue__group.html#ga93115ce0cf2963147f75857621f39b2e">em_queue_group_get_first()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html#l00363">363</a> of file <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html">event_machine_queue_group.c</a>.</p>

</div>
</div>
<a id="ga59e3b34707a34f9be634f7b66c25a876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga59e3b34707a34f9be634f7b66c25a876">&#9670;&nbsp;</a></span>em_queue_group_modify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_queue_group_modify </td>
          <td>(</td>
          <td class="paramtype">em_queue_group_t&#160;</td>
          <td class="paramname"><em>queue_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d81/structem__core__mask__t.html">em_core_mask_t</a> *&#160;</td>
          <td class="paramname"><em>new_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_notif</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d8/db3/structem__notif__t.html">em_notif_t</a>&#160;</td>
          <td class="paramname"><em>notif_tbl</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modify the core mask of an existing queue group, asynchronous (non-blocking)</p>
<p>The function compares the new core mask to the current mask and changes the core mapping for the given queue group accordingly.</p>
<p>This operation may be asynchronous, i.e. the change may complete well after this function has returned. Provide notification events, if the application needs to know about the actual completion. EM will send notifications when the operation has completed.</p>
<p>The new core mask is visible through <a class="el" href="../../d9/d01/group__em__queue__group.html#ga0a861d268d820d2b6de1341749b4011a">em_queue_group_get_mask()</a> only after the modify operation has completed.</p>
<p>Note, that depending on the system, the change can also happen one core at a time, so an intermediate mask may be active momentarily.</p>
<p>Only manipulate core mask with the access macros defined in <a class="el" href="../../d3/d7b/event__machine__hw__specific_8h.html">event_machine_hw_specific.h</a> as the implementation underneath may change.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_group</td><td>Queue group to modify </td></tr>
    <tr><td class="paramname">new_mask</td><td>New core mask </td></tr>
    <tr><td class="paramname">num_notif</td><td>Number of entries in notif_tbl (0 for no notification) </td></tr>
    <tr><td class="paramname">notif_tbl</td><td>Array of notifications to send as the operation completes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_OK if successful.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d01/group__em__queue__group.html#ga5660d6d2ae52d46a31a3de832a32be5d">em_queue_group_create()</a>, <a class="el" href="../../d9/d01/group__em__queue__group.html#ga17b2712720cfb7a5875ad21deb39b565">em_queue_group_find()</a>, <a class="el" href="../../d9/d01/group__em__queue__group.html#gaa0231c3fa0532cd4b9d8ebada73c394e">em_queue_group_delete()</a> <a class="el" href="../../d9/d01/group__em__queue__group.html#ga0a861d268d820d2b6de1341749b4011a">em_queue_group_get_mask()</a>, <a class="el" href="../../d9/d01/group__em__queue__group.html#ga45edcc37b6f62912ff4a8a11ae803a99">em_queue_group_modify_sync()</a> </dd></dl>
<p>is_delete</p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d8/dc3/queue_group_8c-example.html#a66">queue_group.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html#l00161">161</a> of file <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html">event_machine_queue_group.c</a>.</p>

</div>
</div>
<a id="ga45edcc37b6f62912ff4a8a11ae803a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga45edcc37b6f62912ff4a8a11ae803a99">&#9670;&nbsp;</a></span>em_queue_group_modify_sync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_queue_group_modify_sync </td>
          <td>(</td>
          <td class="paramtype">em_queue_group_t&#160;</td>
          <td class="paramname"><em>queue_group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/d81/structem__core__mask__t.html">em_core_mask_t</a> *&#160;</td>
          <td class="paramname"><em>new_mask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modify core mask of an existing queue group, synchronous (blocking).</p>
<p>As <a class="el" href="../../d9/d01/group__em__queue__group.html#ga59e3b34707a34f9be634f7b66c25a876">em_queue_group_modify()</a>, but will not return until the operation is complete.</p>
<p>Note that the function is blocking and will not return until the operation has completed across all concerned EM cores. Sync-API calls can block the core for a long (indefinite) time, thus they should not be used to make runtime changes on real time EM cores - consider the async variants of the APIs in these cases instead. While one core is calling a sync-API function, the others must be running the EM dispatch loop to be able to receive and handle the sync-API request events sent internally. Use the sync-APIs mainly to simplify application start-up or teardown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_group</td><td>Queue group to modify </td></tr>
    <tr><td class="paramname">new_mask</td><td>New core mask</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_OK if successful.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d01/group__em__queue__group.html#ga59e3b34707a34f9be634f7b66c25a876">em_queue_group_modify()</a> for an asynchronous version of the API </dd></dl>
<p>is_delete</p>

<p class="definition">Definition at line <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html#l00201">201</a> of file <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html">event_machine_queue_group.c</a>.</p>

</div>
</div>
<a id="ga184240ab56df837903d8494b0b3c180a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga184240ab56df837903d8494b0b3c180a">&#9670;&nbsp;</a></span>em_queue_group_queue_get_first()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_queue_t em_queue_group_queue_get_first </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">em_queue_group_t&#160;</td>
          <td class="paramname"><em>queue_group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize iteration of a queue group's queues and return the first queue handle.</p>
<p>Can be used to initialize the iteration to retrieve all queues associated with the given queue group for debugging or management purposes. Use <a class="el" href="../../d9/d01/group__em__queue__group.html#gaaaf6fab7440b8211aee5714c31ac52e0">em_queue_group_queue_get_next()</a> after this call until it returns EM_QUEUE_UNDEF. A new call to <a class="el" href="../../d9/d01/group__em__queue__group.html#ga184240ab56df837903d8494b0b3c180a">em_queue_group_queue_get_first()</a> resets the iteration, which is maintained per core (thread). The operation should be started and completed in one go before returning from the EO's event receive function (or start/stop).</p>
<p>The number of queues in the queue group (output arg 'num') may not match the amount of queues actually returned by iterating using <a class="el" href="../../d9/d01/group__em__queue__group.html#gaaaf6fab7440b8211aee5714c31ac52e0">em_queue_group_queue_get_next()</a> if queues are added or removed in parallel by another core. The order of the returned queue handles is undefined.</p>
<p>Simplified example: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> num;</div>
<div class="line">em_queue_t q = <a class="code" href="../../d9/d01/group__em__queue__group.html#ga184240ab56df837903d8494b0b3c180a">em_queue_group_queue_get_first</a>(&amp;num, queue_group);</div>
<div class="line"><span class="keywordflow">while</span> (q != <a class="code" href="../../d4/d11/event__machine__types_8h.html#ae8ba676fb5528d220363edad0aeef1ff">EM_QUEUE_UNDEF</a>) {</div>
<div class="line">   q = <a class="code" href="../../d9/d01/group__em__queue__group.html#gaaaf6fab7440b8211aee5714c31ac52e0">em_queue_group_queue_get_next</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aevent__machine__types_8h_html_ae8ba676fb5528d220363edad0aeef1ff"><div class="ttname"><a href="../../d4/d11/event__machine__types_8h.html#ae8ba676fb5528d220363edad0aeef1ff">EM_QUEUE_UNDEF</a></div><div class="ttdeci">#define EM_QUEUE_UNDEF</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d11/event__machine__types_8h_source.html#l00107">event_machine_types.h:107</a></div></div>
<div class="ttc" id="agroup__em__queue__group_html_ga184240ab56df837903d8494b0b3c180a"><div class="ttname"><a href="../../d9/d01/group__em__queue__group.html#ga184240ab56df837903d8494b0b3c180a">em_queue_group_queue_get_first</a></div><div class="ttdeci">em_queue_t em_queue_group_queue_get_first(unsigned int *num, em_queue_group_t queue_group)</div><div class="ttdef"><b>Definition:</b> <a href="../../d5/dd9/event__machine__queue__group_8c_source.html#l00389">event_machine_queue_group.c:389</a></div></div>
<div class="ttc" id="agroup__em__queue__group_html_gaaaf6fab7440b8211aee5714c31ac52e0"><div class="ttname"><a href="../../d9/d01/group__em__queue__group.html#gaaaf6fab7440b8211aee5714c31ac52e0">em_queue_group_queue_get_next</a></div><div class="ttdeci">em_queue_t em_queue_group_queue_get_next(void)</div><div class="ttdef"><b>Definition:</b> <a href="../../d5/dd9/event__machine__queue__group_8c_source.html#l00440">event_machine_queue_group.c:440</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">num</td><td>Pointer to an unsigned int to store the amount of queue groups into. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">queue_group</td><td>Queue group handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The first queue handle or EM_QUEUE_UNDEF if none exist or the queue group is invalid.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d01/group__em__queue__group.html#gaaaf6fab7440b8211aee5714c31ac52e0">em_queue_group_queue_get_next()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html#l00389">389</a> of file <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html">event_machine_queue_group.c</a>.</p>

</div>
</div>
<a id="gaaaf6fab7440b8211aee5714c31ac52e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaf6fab7440b8211aee5714c31ac52e0">&#9670;&nbsp;</a></span>em_queue_group_queue_get_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_queue_t em_queue_group_queue_get_next </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the queue group's next queue handle.</p>
<p>Continues the queue iteration started by <a class="el" href="../../d9/d01/group__em__queue__group.html#ga184240ab56df837903d8494b0b3c180a">em_queue_group_queue_get_first()</a> and returns the next queue handle in the queue group.</p>
<dl class="section return"><dt>Returns</dt><dd>The next queue handle or EM_QUEUE_UNDEF if the queue iteration is completed (i.e. no more queues available for this queue group).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d9/d01/group__em__queue__group.html#ga184240ab56df837903d8494b0b3c180a">em_queue_group_queue_get_first()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html#l00440">440</a> of file <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html">event_machine_queue_group.c</a>.</p>

</div>
</div>
<a id="gabaa122dd3a9403094d693a8b2a6e2c82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabaa122dd3a9403094d693a8b2a6e2c82">&#9670;&nbsp;</a></span>em_queue_group_to_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t em_queue_group_to_u64 </td>
          <td>(</td>
          <td class="paramtype">em_queue_group_t&#160;</td>
          <td class="paramname"><em>queue_group</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a queue_group handle to an unsigned integer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">queue_group</td><td>queue_group handle to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint64_t value that can be used to print/display the handle</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine is intended to be used for diagnostic purposes to enable applications to e.g. generate a printable value that represents an em_queue_group_t handle. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html#l00464">464</a> of file <a class="el" href="../../d5/dd9/event__machine__queue__group_8c_source.html">event_machine_queue_group.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
  <div id="footer" class="tabs">
   <div class="headertitle"> 
     &copy; 2017 Nokia Networks
   </div>
  </div>
 </body>
</html>
