--------------------------------------------------------------------------------
EM API Release Notes
--------------------------------------------------------------------------------

- See em-odp/README for usage and compilation instructions.
- See em-odp/CHANGE_NOTES for changed and added features.

--------------------------------------------------------------------------------
API 3.5 (EM_VERSION_API_MAJOR=3, EM_VERSION_API_MINOR=5)
--------------------------------------------------------------------------------
1. Queue
   (see include/event_machine/api/event_machine_queue.h for documentation)

 - Replace the EM API define 'EM_MAX_QUEUES' with a runtime config file
   option 'queue.max_num'
   (see config/em-odp.conf and the CHANGE_NOTES for v3.5.0)
   In addition, add a new define 'EM_MAX_OUTPUT_QUEUES' and a function that
   returns the current setting for the maximum number of EM queues:
   EM API:
   (removed) EM_MAX_QUEUES
   #define EM_MAX_OUTPUT_QUEUES ...
   int em_queue_get_max_num(void);

 - Conversions between EM queue and device-id, queue-id
   Extract the device-id and/or queue-id from an EM queue handle.
   EM API:
   uint16_t em_queue_get_device_id(em_queue_t queue);
   uint16_t em_queue_get_qid(em_queue_t queue);
   void em_queue_get_ids(em_queue_t queue, uint16_t *device_id, uint16_t *qid);

   Also add a function that let's the user construct a raw
   EM queue handle that may, or may not, refer to a real queue.
   This is for event-chaining / BIP use cases:
   EM API:
   em_queue_t em_queue_handle_raw(uint16_t device_id, uint16_t qid);

2. Event
   (see include/event_machine/api/event_machine_event.h for documentation)

 - Add the em_event_get_pool_subpool() function
   Add a new event API function that returns both the EM event-pool and the
   subpool the event was allocated from.
   EM API:
   em_pool_t em_event_get_pool_subpool(em_event_t event, int *subpool /out/);

3. EM Handle
 - EM-handle to unsigned integer conversion functions.
   Diagnostic conversion-to-'unsigned integer' functions for various EM handles
   added.
   Event, EO, queue group, event group, atomic group, pool, timer and tmo
   handles can be converted to uint64_t:s.
   EM API:
   uint64_t em_atomic_group_to_u64(em_atomic_group_t atomic_group);
   uint64_t em_eo_to_u64(em_eo_t eo);
   uint64_t em_event_group_to_u64(em_event_group_t event_group);
   uint64_t em_event_to_u64(em_event_t event);
   uint64_t em_pool_to_u64(em_pool_t pool);
   uint64_t em_queue_group_to_u64(em_queue_group_t queue_group);
   uint64_t em_timer_to_u64(em_timer_t timer);
   uint64_t em_tmo_to_u64(em_tmo_t tmo);

   The queue handle can be converted to an uint32_t. The queue conversion
   is different since it reflects the fact that the queue handle consists
   of a 16-bit device-id and a 16-bit queue-id.
   EM API:
   uint32_t em_queue_to_u32(em_queue_t queue);

4. EM device-ID
   (see include/event_machine/platform/event_machine_init.h for documentation)

 - Add a function that returns the EM device-id for the current instance.
   This is a convenience function that returns the EM device-id given by the
   user to em_init() via the em_conf_t::device_id field.
   The function should only be called after a successful EM initialization.
   EM API:
   uint16_t em_device_id(void);

--------------------------------------------------------------------------------
API 3.4 (EM_VERSION_API_MAJOR=3, EM_VERSION_API_MINOR=4)
--------------------------------------------------------------------------------
1. Dispatch
   (see include/event_machine/api/event_machine_dispatcher.h for documentation)

 - Dispatch APIs with duration and option arguments for more control of the
   dispatch loop.

   EM API:
   void em_dispatch_opt_init(em_dispatch_opt_t *opt);

   em_status_t em_dispatch_duration(const em_dispatch_duration_t *duration,
                                    const em_dispatch_opt_t *opt,
                                    em_dispatch_results_t *results /*out*/);

   and the simplified versions of em_dispatch_duration():

   em_status_t em_dispatch_ns(uint64_t ns,
                              const em_dispatch_opt_t *opt,
                              em_dispatch_results_t *results /*out*/);
   em_status_t em_dispatch_events(uint64_t events,
                                  const em_dispatch_opt_t *opt,
                                  em_dispatch_results_t *results /*out*/);
   em_status_t em_dispatch_rounds(uint64_t rounds,
                                  const em_dispatch_opt_t *opt,
                                  em_dispatch_results_t *results /*out*/);

   These APIs gives the user more control over the dispatching of events.
   The user can select to dispatch for a certain number of rounds,
   a certain amount of time or until a certain amount of events have been
   dispatched.
   Options to exit the dispatching when no events are available are also added.
   Further, options to control the event burst-size, the scheduler
   wait-for-events and the pausing of scheduling on return are added.

2. Pool
   (see include/event_machine/platform/event_machine_pool.h for documentation)

- Add a new (special) field to the pool-statistics selection options
  in the EM API:
  em_pool_stats_opt_t::core_cache_available

  This new, and a bit special, EM event pool statistics option enables
  applications to read the number of events/bufs available in the
  core/thread-local pool-cache of the underlying ODP pool(s), but do so with
  ODP APIs only (e.g. odp_pool_stats()).
  The EM pool statistics APIs do not support fetching '.core_cache_available'
  directly because EM has no reliable way of mapping ODP threads to EM cores in
  all possible ODP-thread setups. Thus EM allows for this statistics to be setup
  for an EM pool but the reading must be done by the application using ODP APIs
  for the ODP pools that correspond to a certain EM pool. The application must
  then itself figure out which ODP thread maps to which EM core and which are
  "extra" ODP control or other theads.

  Example usage
  -------------
  A) Create an EM pool with 'core_cache_available'-statistics enabled:
  em_pool_cfg_t pool_cfg;

  em_pool_cfg_init(&pool_cfg);
  ...
  pool_cfg.stats_opt.in_use = true;
  pool_cfg.stats_opt.opt.core_cache_available = 1;
  ...
  em_pool_t pool_em = em_pool_create("my-pool", EM_POOL_UNDEF, &pool_cfg);

  B) To read the cached-per-thread statistics we need ODP APIs:

  odp_pool_t odp_pools[EM_MAX_SUBPOOLS];

  /* Get the nbr of subpools (= ODP pools) in the EM pool */
  int num = em_pool_get_num_subpools(pool_em);

  if (num > 0) {
	/* Get the ODP pools used as subpools in the EM event pool */
  	int ret = em_odp_pool2odp(pool_em, odp_pools, num); /* EM<->ODP conversion extension */

	if (ret > 0) {
		for (int i = 0; i < ret; i++) {
			odp_pool_stats_t stats;

			stats.thread.first = x;
			stats.thread.last = y;
			err = odp_pool_stats(odp_pools[i], &stats /*in/out*/);
			/*
			 * stats.thread.cache_available[...] now contains
			 * cached-per-thread stats for odp_pools[i]
			 */
			...
		}
	}
  }

--------------------------------------------------------------------------------
API 3.3 (EM_VERSION_API_MAJOR=3, EM_VERSION_API_MINOR=3)
--------------------------------------------------------------------------------
1. Timer
   (see include/event_machine/add-ons/event_machine_timer.h for documentation)

 - Timer Ring
   - Add a new event type EM_EVENT_TYPE_TIMER_IND that will be used by the
     timer ring (instead of EM_EVENT_TYPE_TIMER).
     Keep the EM_EVENT_TYPE_TIMER available for application use, as it might have
     been used by the applications prior to the API v3.2 update.

 - Update the specification to state that only the major event types
   EM_EVENT_TYPE_SW, EM_EVENT_TYPE_PACKET and EM_EVENT_TYPE_TIMER can be used as
   a timeout indication. Additionally, the type EM_EVENT_TYPE_TIMER_IND is used
   by the timer ring.

 - Get timer from timeout:
    EM API:
    em_timer_t em_tmo_get_timer(em_tmo_t tmo);
    Get the related timer handle from a timeout handle.

2. Event
   (see include/event_machine/api/event_machine_event.h for documentation)

 - Partial Event Clone:
   Add a new EM API to be able to partially clone an event (and its user area):
   EM API:
   em_event_t em_event_clone_part(em_event_t event, em_pool_t pool/*or EM_POOL_UNDEF*/,
                                  uint32_t offset, uint32_t len, bool clone_uarea);

3. Pool
   (see include/event_machine/platform/event_machine_pool.h for documentation)

 - Selected Pool Statistics
   Read/print only a selected subset of the pool statistic counters
     EM APIs:
     em_status_t em_pool_stats_selected(em_pool_t pool,
                                        em_pool_stats_selected_t *pool_stats/*out*/,
                                        const em_pool_stats_opt_t *opt);
     void em_pool_stats_selected_print(em_pool_t pool, const em_pool_stats_opt_t *opt);
     int em_pool_subpool_stats_selected(em_pool_t pool, const int subpools[], int num_subpools,
                                        em_pool_subpool_stats_selected_t subpool_stats[]/*out*/,
                                        const em_pool_stats_opt_t *opt);
     void em_pool_subpool_stats_selected_print(em_pool_t pool, const int subpools[],
                                               int num_subpools, const em_pool_stats_opt_t *opt);

 - Get the number of subpools in an EM event pool
   EM API:
   int em_pool_get_num_subpools(em_pool_t pool);

--------------------------------------------------------------------------------
API 3.2 (EM_VERSION_API_MAJOR=3, EM_VERSION_API_MINOR=2)
--------------------------------------------------------------------------------
1. Timer: timer version updated to v2.3,
   (see include/event_machine/add-ons/event_machine_timer.h for documentation)

 - Timer Ring
   EM APIs:
   em_status_t em_timer_ring_attr_init(em_timer_attr_t *ring_attr,
                                       em_timer_clksrc_t clk_src, uint64_t base_hz,
                                       uint64_t max_mul, uint64_t res_ns);
   em_status_t em_timer_ring_capability(em_timer_ring_param_t *ring);
   em_timer_t em_timer_ring_create(const em_timer_attr_t *ring_attr);
   em_status_t em_tmo_set_periodic_ring(em_tmo_t tmo, em_timer_tick_t start_abs,
                                        uint64_t multiplier, em_event_t tmo_ev);

   An alternative periodic ring timer. As it uses a different abstraction, it is
   created and started via separate ring specific APIs. It has three main
   differencies to the regular periodic timeouts:
     1. Only a pre-defined read-only event type can be used and is provided
        by the timer ((EM_EVENT_TYPE_TIMER_IND).
     2. Flow control is not supported. Some implementations may have it,
        but the specification does not quarantee any so the user needs to be
        prepared to see the same event enqueued multiple times if handling of
        the received timeouts is not fast enough
     3. Only a limited set of periods are supported per timer (base rate or an
        integer multiple thereof).
   Ring timers can be abstracted as a clock face ticking the pointer forward.
   One cycle around is the base rate (minimum rate). The same timeout can be
   inserted to multiple locations evenly spread within the clock face thus
   multiplying the base rate. Starting offset can be adjusted only up to
   one timeout period.
   Depending on platform, this mode may provide better integration with HW and
   thus less runtime overhead. However, as it exposes potential queue overflows
   and race hazards (race avoidable by using an atomic queue as target) the
   regular periodic timer is recommended as default.

   Example usage:
        em_status_t stat;
        em_timer_ring_attr_t attr;

        stat = em_timer_ring_attr_init(&attr, EM_TIMER_CLKSRC_DEFAULT,
                                       1000 /*Hz*/, 8, 0);
        if (stat != EM_OK) {
                /* given arguments not supported */
        }

        /* optional: set frational frequency, e.g 1000 + 1/3 = 1000.333... Hz */
        attr.ringparam.base_hz.numer = 1;
        attr.ringparam.base_hz.denom = 3;
        if (em_timer_ring_capability(&attr.ringparam) == EM_ERR_NOT_SUPPORTED) {
                /* given (modified) ring params not supported by the timer */
        }

        em_timer_t tmr = em_timer_ring_create(&attr);
        if (tmr == EM_TIMER_UNDEF) {
                /* can't create timer, handle error here or via error handler */
        }

        em_queue_t dst_queue = MY_QUEUE; /* prefer atomic queue to avoid races */
        em_tmo_t tmo = em_tmo_create(tmr, EM_TMO_FLAG_PERIODIC, dst_queue);
        if (tmo == EM_TMO_UNDEF) {
                /* can't create timeout */
        }

        uint64_t multiplier = 1;
        stat = em_tmo_set_periodic_ring(tmo, 0, multiplier,
                                        EM_EVENT_UNDEF /*for event reuse only*/);
        if (stat != EM_OK) {
                /* Could not start timeouts */
        }

        After the setup above, the timer ring will start sending periodic
        timeouts into the given queue. EM will dispatch these events normally
        and call the EO's receive function with the timeout event:

        ==> EM calls the EO's receive function:
        my_eo_receive(..., event, event_type = EM_EVENT_TYPE_TIMER_IND,
                      queue = MY_QUEUE, ...)
        {
                em_tmo_t tmo = EM_TMO_UNDEF;
                em_tmo_type_t tmo_type = em_tmo_get_type(event, &tmo /*out*/,
                                                         false);
                if (tmo_type == EM_TMO_TYPE_PERIODIC) {
                        if (event_type == EM_EVENT_TYPE_TIMER_IND) {
                                /* from timer ring, event read only*/
                        } else {
                                /* from "normal" periodic timer,
                                   event can be modified or swapped in ack */
                        }

                        em_status_t stat = em_tmo_ack(tmo, event);

                        if (stat == EM_OK) {
                                /* ack successful, event consumed by timer */
                                do_work();
                                return;
                        }
                        if (stat == EM_ERR_CANCELED) {
                                /* Last periodic event */
                                /* timeout was canceled and event can be freed */
                        } else {
                                /* other error */
                        }
                }
                ...
        }

- Timout user argument / ptr (can be used with the ring timer)
  EM APIs:
  em_tmo_t em_tmo_create_arg(em_timer_t tmr, em_tmo_flag_t flags,
                             em_queue_t queue, em_tmo_args_t *args);
  void *em_tmo_get_userptr(em_event_t event, em_tmo_t *tmo);

  Attach a user pointer to timer ring timeouts.

- Timeout type
  EM API:
  em_tmo_type_t em_tmo_get_type(em_event_t event, em_tmo_t *tmo, bool reset);

  where the return value of type 'em_tmo_type_t' is a new type that will
  indicate whether the event is a timeout (EM_TMO_TYPE_ONESHOT or
  EM_TMO_TYPE_PERIODIC) or another type of event (EM_TMO_TYPE_NONE).

  typedef enum em_tmo_type_t {
       EM_TMO_TYPE_NONE     = 0, /**< unknown or not timer-related event   */
       EM_TMO_TYPE_ONESHOT  = 1, /**< event is oneshot timeout indication  */
       EM_TMO_TYPE_PERIODIC = 2, /**< event is periodic timeout indication */
  } em_tmo_type_t;

- Specify that only the major event types EM_EVENT_TYPE_SW, EM_EVENT_TYPE_PACKET
  and EM_EVENT_TYPE_TIMER can be used as timeout indication.

- Convert a valid EM timer to an ODP timer_pool.
  EM extension API:
  odp_timer_pool_t em_odp_timer2odp(em_timer_t tmr);

  This is for debugging and using potential future extra odp apis.

2. Error
 - Error codes
   Reorganize the EM error codes better and add the new error codes
   EM_ERR_NOT_CREATED, EM_ERR_NOT_SUPPORTED and EM_ERR_BAD_TYPE.

 - Error handler arguments, documentation fix
   Remove mention that all API function arguments would be passed
   to the error handler - they are not.

3. Separate config define for the event burst size from EM local queues
   (EM_QUEUE_TYPE_LOCAL)

   #define EM_QUEUE_LOCAL_MULTI_MAX_BURST  32

   The maximum number of events from a local queue (EM_QUEUE_TYPE_LOCAL) to
   dispatch in one burst. Allows different burst sizes from scheduled queues vs.
   local queues.

4. Misc.
 - Extension API: Rename pkt_enqueue() to em_odp_pkt_enqueue().
 - Remove the deprecated EM API template files.
 - Event: removed 'const' from the em_free_multi() arg 'events[]'
   Changed 'void em_free_multi(const em_event_t events[], int num);'
   to 'void em_free_multi(em_event_t events[], int num);'
   since EM might need to filter out events that can not / should not
   be freed, e.g. active timer ring events.

--------------------------------------------------------------------------------
API 3.1 (EM_VERSION_API_MAJOR=3, EM_VERSION_API_MINOR=1)
--------------------------------------------------------------------------------
1. Pool Statistics
   (see include/event_machine/platform/event_machine_pool.h for documentation)

   EM APIs:
   em_status_t em_pool_stats(em_pool_t pool, em_pool_stats_t *pool_stats/*out*/);
   em_status_t em_pool_stats_reset(em_pool_t pool);
   void em_pool_stats_print(em_pool_t pool);

   int em_pool_subpool_stats(em_pool_t pool, const int subpools[], int num_subpools,
                             em_pool_subpool_stats_t subpool_stats[]/*out*/);
   em_status_t em_pool_subpool_stats_reset(em_pool_t pool, const int subpools[],
                                           int num_subpools);
   void em_pool_subpool_stats_print(em_pool_t pool, const int subpools[],
                                    int num_subpools);

   New EM event pool statistics APIs and configuration allow the applications to
   choose which pool statistic counters to collect and retrieve.
   Configuration of pool statistics is done globally via the EM config file
   (config/em-odp.conf: 'pool.statistics') or per pool through the updated
   'em_pool_cfg_t::stats_opt' given to em_pool_create().
   The new APIs allow the user to retrieve pool statistics on an EM event pool
   level or, more fine grained, on a subpool level.
   The statistics 'reset'-APIs clear some of the counters, see the details in
   the API function documentation.
   Additionally, 'print'-APIs have been added for easy printout of statistics.

   Changes to em_pool_create() are needed to configure pool-statistics on a
   per-pool basis (thus overriding the EM config file settings for the pool):
     em_pool_t em_pool_create(..., const em_pool_cfg_t *pool_cfg);
   The new 'em_pool_cfg_t::stats_opt{...}' fields controls which statistics are
   gathered.
   The existing em_pool_cfg_init() API can hide the 'pool_cfg' changes if the
   user does not need updated pool statistics (note: changes to the config file
   are still needed).

   The 'pool info' APIs are unmodified and produce the same output as before,
   event though the statistics configuration in the config file or in pool
   creation has changed. See the APIs em_pool_info(), em_pool_info_print(),
   em_pool_info_print_all()). To fully mimic the previous behaviour of the
   'pool info' APIs with statistics in use, enable the pool statistics options
   'available = true' and 'cache_available = true' via em_pool_cfg_t::stats_opt
   or the EM config file.

2. Timer
   (see include/event_machine/add-ons/event_machine_timer.h for documentation)

   em_tmo_set_rel/abs/periodic():
   - Clarification of return value on error:
     When the timeout tick value given to em_tmo_set_...() is in the past or is
     too close to current time, the error code EM_ERR_TOONEAR is returned.
     In this case EM will not call the error handler, instead it's up to the
     application to decide whether to retry with an updated time or treat the
     condition as an error. The given event is not consumed on error, the overship
     remains with the caller.
   - Starting a periodic tmo could previously be done with em_tmo_set_rel(),
     this has been obsoleted and cannot be used any more.
     The API em_tmo_set_periodic() must now be used instead.

   em_tmo_cancel():
   The same return value change applies also to em_tmo_cancel(): if attempted
   too late, em_tmo_cancel() also now returns EM_ERR_TOONEAR and does not call
   the error handler.
   Additionally, a more strict state check has been applied and the API will
   fail if e.g. attempted twice.

3. Event Vectors
   (see include/event_machine/api/event_machine_event.h for documentation)

   Update documentation for em_event_vector_size_set():
   Explicitly mention that a vector's event-table must be updated properly with
   events before setting the vector size. EM always assumes that there are as
   many valid events in the event-table as indicated by 'size':
   "The events must be stored into the vector before setting the size,
    i.e. first add/remove events to/from the vector's event-table (within
    max-size limits) and only after that set the size."

--------------------------------------------------------------------------------
API 3.0 (EM_VERSION_API_MAJOR=3, EM_VERSION_API_MINOR=0)
--------------------------------------------------------------------------------

1. Event References
   (see include/event_machine/api/event_machine_event.h for documentation)
   EM APIs:
     em_event_t em_event_ref(em_event_t event);
     bool em_event_has_ref(em_event_t event);

   Normally, each event is associated with one event handle (em_event_t) - each
   event allocation produces a new event (and associated payload data) that can
   be processed, sent or freed. When the user EO has allocated or received an
   event from a queue, the event payload data may be read and written as needed
   by the application.
   An exception to the above described scenario happens when using event
   references.
   An event reference is an additional event handle referring to an existing
   event. New references are created with the em_event_ref() API call. The
   intent of using multiple references is to avoid event copies.
   An event that has multiple references shares its data with the other
   reference handles and thus the (shared) data must not be modified.
   Reading event data from a reference is allowed. Writes to the event data must
   only be done when there is a single event handle left, i.e. when
   em_event_has_ref(event) returns 'false'. Results are undefined if these
   restrictions are not observed.
   The event is freed when the last reference, including the original event,
   is freed.
   It is not allowed to use event references with event groups since assigning
   an event that has references to an event group would assign all the
   references to the event group resulting in undefined behaviour. E.g. using
   em_send_group()/em_send_group_multi() to send a reference is wrong.

2. Event Vectors
   (see include/event_machine/api/event_machine_event.h for documentation)
   EM APIs:
     void em_event_vector_free(em_event_t vector_event);
     uint32_t em_event_vector_tbl(em_event_t vector_event, em_event_t **event_tbl/*out*/);
     uint32_t em_event_vector_size(em_event_t vector_event);
     void em_event_vector_size_set(em_event_t vector_event, uint32_t size);
     uint32_t em_event_vector_max_size(em_event_t vector_event);
     em_status_t em_event_vector_info(em_event_t vector_event,
                                      em_event_vector_info_t *vector_info/*out*/);
     Note: Event Vectors always have the major part of their event type set to
           'EM_EVENT_TYPE_VECTOR'.

   Vector events contain a table of events.
   All events in the event-table must be of major type EM_EVENT_TYPE_PACKET.
   Storing events of another type into the event-table is an error and leads to
   undefined behaviour.
   Event vector pools are created with em_pool_create() with the pool event-type
   set to EM_EVENT_TYPE_VECTOR. Event vectors can then be allocated from vector
   pools by calling em_alloc(..., vector_pool).
   To free the vector event along with all events it contains, use em_free() or
   em_free_multi().
   To free the vector event only, not the events it contains,
   use em_event_vector_free().

   Extension APIs for 'em-odp' (needed to set up pktio to use vectors)
   (see include/event_machine/platform/event_machine_odp_ext.h)
   - Get the ODP schedule group that corresponds to the given EM queue gruop
     odp_schedule_group_t em_odp_qgrp2odp(em_queue_group_t queue_group);
   - Map the given scheduled ODP pktin event queues to new EM queues.
     int em_odp_pktin_event_queues2em(const odp_queue_t odp_pktin_evqueues[/*num*/],
                                      em_queue_t queues[/*out:num*/], int num);

3. Vector Pools
   (see include/event_machine/platform/event_machine_pool.h for documentation)
   EM pools for Event Vectors can now be created via the em_pool_create() API.
   The pool config struct is extended to allow .event_type = EM_EVENT_TYPE_VECTOR.

   Changes to pool creation via configuration struct 'em_pool_cfg_t':
   - em_pool_cfg_t::event_type:
     The event type determines the pool type to create, now it supports vectors.
     Using EM_EVENT_TYPE_VECTOR here creates subpools of type 'ODP_POOL_VECTOR'.
     This kind of EM pool can ONLY be used for creating event vectors.
   - em_pool_cfg_t::subpool[].size:
     (when .event_type = EM_EVENT_TYPE_VECTOR)
     Max number of events in a vector from the subpool, i.e.
     'number of em_event_t:s in the vector's event-table[]'.
     EM does not initialize the vector.
     Note! The meaning of .size is slightly different for "normal" event pools
           vs. vector pools.

4. Vector allocation and freeing
   (see include/event_machine/api/event_machine_event.h for documentation)
   Event vectors can be allocated from vector pools using the existing
   APIs em_alloc() or em_alloc_multi() by providing
   (major) type=EM_EVENT_TYPE_VECTOR and pool='vector-pool':
     - em_event_t em_alloc(uint32_t size, em_event_type_t type, em_pool_t pool);
     - int em_alloc_multi(em_event_t events[/*out*/], int num,
                          uint32_t size, em_event_type_t type, em_pool_t pool);
   Minor change to the alloc APIs for the type and meaning of the 'size' arg:
         1) Packet & sw-buf: event size in bytes (B), size > 0.
   *new* 2) Vector: number of event handles that should fit into
                    the vector table of the event, size > 0.
   The change was needed when introducing EM vector-events into to API,
   here the event alloc-size indicates the number of events that should
   fit into the vector and not a byte-size, so uint32_t makes more sense
   and is also more in line with the types used during pool-creation.

   Freeing a vector can be done with em_free/_multi(), which frees the vector
   and all events it contains. Alternatively, use em_event_vector_free(), which
   only frees the vector and not the events in the contained event table.

5. Helper: EM debug timestamps
   (see include/event_machine/helper/event_machine_debug.h for documentation)
   Helper APIs:
     uint64_t em_debug_timestamp(em_debug_tsp_t tsp);

   Use em_debug_timestamp() to retrieve a 'per EM thread' dispatcher timestamp
   from EM internal timestamp-points (tsp) that can be compared to the current
   time to determine e.g. scheduling latency or other overheads.
   Not for normal application use!
   Disabled by default (returns 0) and can be enabled via the configure option
   '--enable-debug-timestamps' or by changing the 'EM_DEBUG_TIMESTAMP_ENABLE'
   define.
   The type 'em_debug_ts_t' defines the available internal EM timestamp points,
   see the type definition.

6. Other
   Event: rename functions for major and minor event types
   Rename em_get_type_major() to em_event_type_major() and
          em_get_type_minor() to em_event_type_major().
   Create defines for the old names for backwards compatibility.

   Event: em_event_get_size() - returns uint32_t instead of size_t to reflect
                                changes in em_alloc() etc.
   Hooks: em_api_hook_alloc_t - arg 'size' changed to uint32_t instead of size_t
                                to reflect changes in em_alloc() etc.

--------------------------------------------------------------------------------
API 2.10 (EM_VERSION_API_MAJOR=2, EM_VERSION_API_MINOR=10)
--------------------------------------------------------------------------------
Backwards compatible with EM 2.9 API

1. EM Idle Hooks
   (see include/event_machine/platform/event_machine_hooks.h and
    CHANGE_NOTES for more documentation and details)
   EM APIs:
     em_status_t em_hooks_register_to_idle(em_idle_hook_to_idle_t func);
     em_status_t em_hooks_unregister_to_idle(em_idle_hook_to_idle_t func);
     em_status_t em_hooks_register_to_active(em_idle_hook_to_active_t func);
     em_status_t em_hooks_unregister_to_active(em_idle_hook_to_active_t func);
     em_status_t em_hooks_register_while_idle(em_idle_hook_while_idle_t func);
     em_status_t em_hooks_unregister_while_idle(em_idle_hook_while_idle_t func);
   Up to 'EM_CALLBACKS_MAX' idle hooks of each type can be registered.

   Alternatively, the idle hooks can be provided as arguments to em_init()
   at start-up:
     em_init(em_conf_t::idle_hooks.to_idle_hook
                                  .to_active_hook
                                  .while_idle_hook);
   The arg 'em_conf_t conf' of em_init() has new fields in
   em_conf_t::idle_hooks{}. The usage if em_init() and em_conf_t is backwards
   compatible with API v2.9 since em_conf_init(&conf) will init the new fields
   to NULL/0;

   EM Idle hook functions can be registered for tracking the idle state
   (ACTIVE/IDLE) of EM cores:
   'To_idle' hooks are called when the core state changes from ACTIVE to IDLE.
   'To_active' hooks are called when the core state changes from IDLE to ACTIVE.
   'While_idle' hooks are called when the core is already in the IDLE state and
   doesn't get any events from scheduled or local queues.

   Idle hook support is only available when EM_IDLE_HOOKS_ENABLE != 0
   (see the configure --enable-idle_hooks option)

2. Startup Pools in config file
   (see config/em-odp.conf and CHANGE_NOTES for more documentation and details)
   Configure EM event-pools via the EM config file. These pools will be created
   during EM startup. The changes are mostly related to the EM config file but
   impacts how the em_conf_t::default_pool_cfg given to em_init() is used:
     - if the default pool configuration is also given in the config file
       through the 'startup_pools' option, it will override the default pool
       configuration given via em_conf_t::default_pool_cfg to em_init().

--------------------------------------------------------------------------------
API 2.9 (EM_VERSION_API_MAJOR=2, EM_VERSION_API_MINOR=9)
--------------------------------------------------------------------------------
Backwards compatible with EM 2.8 API

1. API documentation clean-up.
2. The define EM_MAX_QUEUES increased from 960 to 1024.

--------------------------------------------------------------------------------
API 2.8 (EM_VERSION_API_MAJOR=2, EM_VERSION_API_MINOR=8)
--------------------------------------------------------------------------------
Backwards compatible with EM 2.7 API

1. Add a define for the base-name of the EM core-specific queue groups (one per
   EM-core): #define EM_QUEUE_GROUP_CORE_BASE_NAME "core"
   The full queue group name for a single-core queue group is: "core" + "%d",
   which gives "core0", "core1", ... "core99", ...
   EM earlier relied on these queue groups for internal core specific
   messaging and also allowed applicatioins to use them. Currently EM
   does not internally need these groups but will create them based on
   an EM config file option for applications relying on their existence.

--------------------------------------------------------------------------------
API 2.7 (EM_VERSION_API_MAJOR=2, EM_VERSION_API_MINOR=7)
--------------------------------------------------------------------------------
Backwards compatible with EM 2.6 API

1. EM version number APIs:
   (see include/event_machine/api/event_machine_version.h.in, which is used to
    create event_machine_version.h during package configuration/build)
  - Version number macros and define constants that can be used to identify the
    EM API and implementation versions at build time.
    Can be used for conditional compilation:
        #if EM_VERSION > EM_VERSION_NUM(2.7.0.0) ...
          or
        #if EM_VERSION_API > EM_VERSION_API_NUM(2.7) ...
  - Runtime API functions that can be used to check the EM API and
    implementation numbers at runtime.
    The build-time and runtime versions numbers may differ e.g. if the
    application has been compiled against the header files of a certain
    EM release and later the EM shared library is updated without recompilation
    of the application.
      const char *em_version_api_str(void);
      unsigned int em_version_api_num(void);
      const char *em_version_str(void);
      unsigned int em_version_num(void);

2. EM Event User Area:
   (see include/event_machine/api/event_machine_event.h)
   The event user area is a fixed sized area located within the event metadata
   (i.e. outside of the event payload) that can be used to store application
   specific event related data without the need to adjust the payload.
   The event user area is configured during EM event pool creation and thus the
   size of the user area is set per pool.
   Note that the user area content is not initialized by EM, neither em_alloc()
   nor em_free() will touch it and thus it might contain old user data set the
   last time the area was used during a previous allocation of the same event.
   Since the user area is not part of the event payload, it will not be
   transmitted as part of a packet etc.

   - Get a pointer to the event user area, optionally along with its size.
     void *em_event_uarea_get(em_event_t event, size_t *size/*out*/);

   - Pool config for the Event User Area.
     (see include/event_machine/platform/event_machine_pool.h)
     Pool config em_pool_cfg_t::user_area.{.in_use, .size} has been updated to
     include configuration options for the event user area.
     The default event user area size can additionally be set via the
     EM config file config/em-odp.conf:
     pool: {
        ...
        # Default event user area size in bytes for all events from all pools.
        #
        # This is a global setting that can be overridden per pool using
        # 'em_pool_cfg_t::user_area{}' with em_pool_create().
        #
        user_area_size = 0
        ...
     }

3. EM Event User Area ID:
   (see include/event_machine/api/event_machine_event.h)
   The event user area can be associated with an optional ID that e.g. can be
   used to identify the contents of the actual user area data. The ID is stored
   outside of the actual user area data and is available for use even if the
   user area size has been set to zero(0) for the pool the event was allocated
   from.
   - Get the event user area ID along with information if it has been set
     em_status_t em_event_uarea_id_get(em_event_t event, bool *isset /*out*/,
                                       uint16_t *id /*out*/);
   - Set the event user area ID
     em_status_t em_event_uarea_id_set(em_event_t event, uint16_t id);

   - Get the event user area information for a given event.
     em_status_t em_event_uarea_info(em_event_t event,
                                     em_event_uarea_info_t *uarea_info /*out*/);

--------------------------------------------------------------------------------
API 2.6 (EM_API_VERSION_MAJOR=2, EM_API_VERSION_MINOR=6)
--------------------------------------------------------------------------------
Backwards compatible with EM 2.5 API

1. Timer:
   (see em-odp/include/event_machine/add-ons/event_machine_timer.h for details)
  - Add new timer clock source choices (em_timer_clksrc_t) to select the
    timer clock source in case multiple are supported:
    EM_TIMER_CLKSRC_0, EM_TIMER_CLKSRC_1, ...(up to)..., EM_TIMER_CLKSRC_5.
    Backwards compatible macros (EM_TIMER_CLKSRC_CPU, EM_TIMER_CLKSRC_EXT) are
    provided for full compatibility with older code.
    EM_TIMER_CLKSRC_DEFAULT is always available and is a fully portable
    definition.

2. Event:
   (see em-odp/include/event_machine/api/event_machine_event.h for details)
  - Event cloning:
    - em_event_t em_event_clone(em_event_t event, em_pool_t pool);
      Allocate a new event with identical payload to the given event.
      The event metadata and internal headers will _not_ be cloned.
      The optional 'pool' argument is used to specify the event pool to allocate
      the cloned event from. Use 'EM_POOL_UNDEF' to clone from the same pool as
      'event' was allocated from.
      The event-type of 'event' must be suitable for allocation from 'pool'
      (e.g. EM_EVENT_TYPE_PACKET can not be allocated from a pool supporting
      only EM_EVENT_TYPE_SW)
      The function returns the cloned event or EM_EVENT_UNDEF on error.

  - Event/Pool: Get the handle of the pool the event was allocated from.
    - em_pool_t em_event_get_pool(em_event_t event);
      Returns the EM event-pool the event was allocated from or EM_POOL_UNDEF if
      no EM pool is found. EM_POOL_UNDEF is returned also for a valid event that
      has been allocated from a pool external to EM (no error is reported).
      The EM event-pool for the given event can only be obtained if the event
      has been allocated from a pool created with em_pool_create(). For other
      pools, e.g. external (to EM) pktio pools, EM_POOL_UNDEF is returned.

  - Marking event(s) as "free"
    - void em_event_mark_free(em_event_t event);
    - void em_event_mark_free_multi(const em_event_t events[], int num);
    Mark the event state as "free" and then rely on HW / mechanisms external
    to EM to actually free the event(s) back into the event pool.
    - em_event_mark_free(): Indicates a user-given promise to EM that the event
      will be freed back into the pool it was allocated from e.g. by HW or
      device drivers (external to EM). Calling em_event_mark_free() transfers
      event ownership away from the user, and thus the event must not be used or
      touched by the user anymore.
      EM will, after this API-call, treat the event as "freed" and any further
      API operations or usage might lead to EM errors (depending on the
      error-check level), e.g. em_send/free/tmo_set/ack(event) etc. is forbidden
      after em_event_mark_free(event).
    - em_event_mark_free_multi(): Similar to em_event_mark_free(), but allows
      the marking of multiple events as "free" with one function call.
    Note: Registered API-callback hooks for em_free/_multi()
          (em_api_hook_free_t) will NOT be called.

 - Unmarking event(s) previously marked "free"
    - void em_event_unmark_free(em_event_t event);
    - void em_event_unmark_free_multi(const em_event_t events[], int num);
    Unmark event(s) previously marked as "free" (i.e mark as "allocated" again).
    Note: This is for recovery situations only and can potenially crash the
          application if used incorrectly! Unmarking the free-state of an event
          that has already been freed will lead to fatal error.
    - em_event_unmark_free(): Revert an event's "free" state, as set by
      em_event_mark_free() back to the state before the mark-free function call.
      Any further usage of the event after em_event_mark_free(), by EM or the
      user, will result in error when calling em_event_unmark_free() since the
      state has become unrecoverable.
      => the only allowed EM API call after em_event_mark_free() (for a certain
         event) is em_event_unmark_free() when it is certain that the event, due
         to some external error, will not be freed otherwise and must be
         recovered back into the EM-domain so that calling em_free() by the user
         is possible.
      Calling em_event_unmark_free() transfers event ownership back to the user
      again.
      Note: Unmark-send and unmark-free are the only valid cases of using an
            event that the user no longer owns, all other such uses leads to
            fatal error.
    - em_event_unmark_free_multi(): Unmark multiple events previously marked as
      "free". Similar to em_event_unmark_free(), but allows to do the
      "free"-unmarking of multiple events with one function call.

3. Queue:
  (see em-odp/include/event_machine/api/event_machine_queue.h)
  - Number of queue priorities:
    - int em_queue_get_num_prio(int *num_runtime);
      The function returns the number of queue priorities available.
      Optionally, the amount of actual runtime priorities can be inquired.
      The valid queue priority range is from 0 (lowest priority) to
      em_queue_get_num_prio() - 1.
      The runtime environment may provide a different amount of priority levels.
      EM priorities are in that case mapped to the runtime values depending on
      "priority map-mode" selected in the runtime configuration file
      (config/em-odp.conf).

4. Extension APIs for EM<->ODP conversions:
   (see include/event_machine/platform/event_machine_odp_ext.h)
  - Convert between EM and ODP pools:
    - int em_odp_pool2odp(em_pool_t pool, odp_pool_t odp_pools[/out/], int num);
    - em_pool_t em_odp_pool2em(odp_pool_t odp_pool);

    - em_odp_pool2odp(): Get the ODP pools used as subpools in a given EM event
      pool. An EM event pool consists of 1 to 'EM_MAX_SUBPOOLS' subpools. Each
      subpool is an ODP pool. This function outputs the ODP pool handles of
      these subpools into a user-provided array and returns the number of
      handles written. The obtained ODP pools must not be deleted or altered
      outside of EM, e.g. these ODP pools must only be deleted as part of an
      EM event pool using em_pool_delete().
      ODP pool handles obtained through this function can be used to
        - configure ODP pktio to use an ODP pool created via EM (allows for
          better ESV tracking)
        - print ODP-level pool statistics with ODP APIs etc.
      The function returns the number of ODP pools filled into 'odp_pools[]'.

    - em_odp_pool2em(): Get the EM event pool that a given ODP pool belongs to.
      An EM event pool consists of 1 to 'EM_MAX_SUBPOOLS' subpools. Each subpool
      is an ODP pool. This function returns the EM event pool that contains the
      given ODP pool as a subpool or EM_POOL_UNDEF if the ODP pool is not part
      of any EM event pool.

--------------------------------------------------------------------------------
API 2.5 (EM_API_VERSION_MAJOR=2, EM_API_VERSION_MINOR=5)
--------------------------------------------------------------------------------
Not backwards compatible with previous API version, API 2.5 contains modified
types and functions requiring small changes to older code.

1. Timer: timer version updated from v2.0 to v2.1,
   see em-odp/include/event_machine/add-ons/event_machine_timer.h for details.
   - New Timer APIs for tick<->ns conversions:
     - em_timer_tick_to_ns()
     - em_timer_ns_to_tick()

   - New Error return codes for em_tmo_set_abs() and em_tmo_set_periodic()
     related to timing errors:
     EM_OK          success (event taken)
     EM_ERR_TOONEAR failure, tick value is past or too close to current time
     EM_ERR_TOOFAR  failure, tick value exceeds timer capability (too far ahead)
     (other_codes)  other failure
     New Error return codes for em_tmo_ack():
     EM_OK            success
     EM_ERR_CANCELED  timer has been cancelled
     (other_codes)    failure

2. Event: New APIs introduced together with EM feature
          "Event State Verification" (ESV), see CHANGE_NOTES for EM v2.5.0.
   - em_event_mark_send(event, queue): Mark the event as "sent" (without
     calling em_send...()).
     Indicates a user-given promise to EM that the event will later appear into
     'queue' by some means other than an explicit user call to em_send...().
     Calling em_event_mark_send() transfers event ownership away from the user,
     and thus the event must not be used or touched by the user anymore (the
     only exception is (hw) error recovery where the "sent" state can be
     cancelled by using em_event_unmark_send() - dangerous!).

   - em_event_unmark_send(event): Unmark an event previously marked as "sent"
                                  (i.e mark as "unsent")
     Note: This is for recovery situations only and can potenially crash the
           application if used incorrectly!
     Revert an event's "sent" state, as set by em_event_mark_send(), back to the
     state before that function call.
     Any further usage of the event after em_event_mark_send(), by EM or
     the user, will result in error when calling em_event_unmark_send() since
     the state has become unrecoverable.
       => the only allowed EM API call after em_event_mark_send() is
          em_event_unmark_send() if it is certain that the event, due to some
          external error, will never be sent into EM again otherwise.
     Calling em_event_unmark_send() transfers event ownership back to the user
     again.
     Note2: This is the only valid case of using an event that the user no
            longer owns - all other such uses leads to fatal error.

3. Pool:
   - Possibility to set the event payload headroom of pkt-events during
     EM event pool creation (em_pool_create()) with the new config params:
     em_pool_cfg_t::pkt.headroom.in_use & .value

4. Extension APIs for EM<->ODP conversions
  - Conversion functions between EM events to/from ODP events changed:
    - void em_odp_events2odp(const em_event_t events[],
                             odp_event_t odp_events[/*out*/], const int num)
    - void em_odp_events2em(const odp_event_t odp_events[],
                            em_event_t events[/*out*/], const int num)

5. Misc
   - Improved C++ support: including EM API header files into a C++ project
     now avoids errors related to C vs. C++ typecasting.
   - API function pointer arguments should be "const" if object is not modified

--------------------------------------------------------------------------------
API 2.4 (EM_API_VERSION_MAJOR=2, EM_API_VERSION_MINOR=4)
--------------------------------------------------------------------------------
Not backwards compatible with previous API version, API 2.4 contains modified
types requiring small changes to older code.

1. Timer: timer version updated from v1.1 to v2.0,
   see em-odp/include/event_machine/add-ons/event_machine_timer.h for details.
   New or updated timer types and APIs:
   - em_timer_attr_t: *updated* type that MUST be initialized with
                      em_timer_attr_init() before passing it to
                      em_timer_create().
     Note: timer resolution is given to em_timer_create() as either
           nanoseconds or Hertz:
           em_timer_attr_t::resparam.res_ns or .res_hz (new option).
           The user must choose which one to use by setting the other one to 0.

   - em_timer_attr_init(): Mandatory initialization of timer attributes.
     Enforce the following sequence:
        em_timer_attr_t attr;
        em_timer_attr_init(&attr); /* Now mandatory */
        ...
        em_timer_t tmr = em_timer_create(&attr);
     Timer-create will fail if attr-init has been omitted.

   - em_timer_capability() & em_timer_capability_t: Inquire timer capabilities.

   - em_timer_res_capability() & em_timer_res_param_t:
     Inquire timer capabilities for a specific resolution or maximum timeout.

   - em_tmo_set_periodic(): Allow an absolute start time for periodic timeouts
     with the new API em_tmo_set_periodic(..., em_timer_tick_t start_abs, ...)
     Note: Prefer the new em_tmo_set_periodic() for activating/setting periodic
           timeouts over em_tmo_set_rel().
           Use em_tmo_set_abs() or em_tmo_set_rel() for oneshot timeouts.

   - em_tmo_get_stats() & em_tmo_stats_t: Get timeout statistics counters.
     Currently meaningful for periodic timeouts only, 0 otherwise.

2. Pool:
   - em_pool_cfg_init(): pool-config initialization function.
     Initialize EM-pool configuration parameters for em_pool_create(),
     i.e. set em_pool_cfg_t to default values for all fields.
     After initialization, the user further needs to update the fields of
     'em_pool_cfg_t' with appropriate sizing information before calling
     em_pool_create().
     Always initialize 'pool_cfg' first with em_pool_cfg_init(pool_cfg) to
     ensure backwards compatibility with potentially added new options.

   - Possibility to configure the core-local event-cache per subpool via
     em_pool_cfg_t::cache_size during EM-pool creation.
     The 'cache_size' param is defined in em_pool_cfg_t as:
     " Maximum number of locally cached subpool events per EM-core.
       Allocating or freeing events from a core-local event-cache
       can be faster than using the global event subpool. Cached
       events are only available on the local core and can reduce
       the number of globally free events in the subpool, thus set
       'num > EM-core-count * cache_size'.
       The actual used cache_size will be smaller than or equal to
       the requested value, depending on the implementation."

3. EO: init: eo-multircv params must be initialized before creating EO.
   Enforce the following sequence:
        em_eo_multircv_param_t param;
        em_eo_multircv_param_init(&param); /* Now mandatory */
        eo = em_eo_create_multircv(..., param);
   EO-create will fail if param-init has been omitted.

4. Queue:
   - em_queue_get_index(): Get a unique index from a given EM queue handle.
     Get a unique index corresponding to the given EM queue handle.
     Returns a unique index in the range 0...EM_MAX_QUEUES-1.
     The same EM queue handle will always map to the same index.
     Only meaningful for queues created within the current EM instance.

4. Add missing const qualifiers into the API.
   Some API calls missed const qualifiers on read-only data pointers.
   Add the missing 'const' and fix the implementation accordingly.

--------------------------------------------------------------------------------
API 2.3 (EM_API_VERSION_MAJOR=2, EM_API_VERSION_MINOR=3)
--------------------------------------------------------------------------------
Not backwards compatible with previous API version, API 2.3 contains modified
types requiring small changes to older code (see 2, 4 and 5).

1. Event: multi-event alloc and free functions
   APIs for allocating or freeing multiple events.
   - em_alloc_multi(): Allocate multiple events.
     Similar to em_alloc(), but allows allocation of multiple events, with same
     properties, with one function call.
     The em_alloc_multi() API function will try to allocate the requested number
     ('num') of events but may fail to do so, e.g. if the pool has run out of
     events, and will return the actual number of events that were successfully
     allocated from the given pool.
   - em_free_multi(): Free multiple events.
     Similar to em_free(), but allows freeing of multiple events with one
     function call.
   See include/event_machine/api/event_machine_event.h:
   em_alloc_multi() and em_free_multi()

2. Hooks: use the same hook-type for all alloc():s and the same for all free():s
   em_api_hook_alloc_t: API-callback hook for em_alloc() and em_alloc_multi().
   em_api_hook_free_t:  API-callback hook for em_free() and em_free_multi().
   Note! em_api_hook_alloc_t and em_api_hook_free_t _changed_ in API 2.3
         to suit both single and multi alloc and frees.
   See include/event_machine/platform/event_machine_hw_types.h:
   em_api_hook_alloc_t and em_api_hook_free_t

3. EO: multi-event EO-receive function
   'em_receive_multi_func_t':
   Similar to the single-event receive function (em_receive_func_t), except that
   multiple events can be passed with one call to the EO receive function.
   A multi-event receive function is taken into use during EO creation with a
   call to em_eo_create_multircv(...). The maximum number of events that the
   multi-event EO receive function is prepared to handle can be set with the
   option 'em_eo_multircv_param_t::max_events' given to em_eo_create_multircv().
   The EM dispatcher will split event batches larger than 'max_events' into
   chunks of 'max_events'.
   Event group handling: All events passed by the EM dispatcher to the
   EO multi-event receive function belong to the same event group (or none)
   - a batch of events containing multiple event groups is split by the
   dispatcher into smaller chunks, each chunk belonging to the same event group
   (or none). The event group count is decremented by the number of events
   passed to the receive function when execution returns to the dispatcher.
   See include/event_machine/api/event_machine_eo.h:
   em_receive_multi_func_t and em_eo_create_multircv().

4. Dispatch: one common enter-callback for multi- and single-receive funcs.
   em_dispatch_enter_func_t: the dispatch enter callback, called before entering
   an EO-receive function, is changed so that one common callback type can be
   used for both single-event and multi-event EO-receive functions.
   Note! 'em_dispatch_enter_func_t' _changed_ in EM API v2.3.
   See include/event_machine/api/event_machine_dispatcher.h:
   em_dispatch_enter_func_t and em_dispatch_register_enter_cb()

5. Init: core masks for 'input_poll_fn' and 'output_drain_fn' added to em_conf_t
   Add the 'input_poll_mask' and 'output_drain_mask' fields to em_conf_t.
   These masks define the logical EM cores on which these functions
   are executed.
   Note! New fields added to em_conf_t in API 2.3, user must initialize these
         added fields - use em_conf_init(), see 6.
   See include/event_machine/platform/event_machine_init.h:
   em_conf_t and em_conf_init()

6. Init: use em_conf_init(em_conf_t *conf) to init the EM config params.
   Using em_conf_init() provides better backwards compatibility since
   all options will be set to default values before use.
   All users should call em_conf_init() before calling em_init()!
   See include/event_machine/platform/event_machine_init.h:
   em_conf_t and em_conf_init()

7. Event: APIs to get the event type(s) of multiple events
   Two EM APIs added:
   - Get the event types of multiple events:
     em_event_get_type_multi()
   - Get the number of events that have the same event type:
     em_event_same_type_multi()
   See include/event_machine/api/event_machine_event.h:
   em_event_get_type_multi() and em_event_same_type_multi()

--------------------------------------------------------------------------------
API 2.2 (EM_API_VERSION_MAJOR=2, EM_API_VERSION_MINOR=2)
--------------------------------------------------------------------------------
  Backwards compatible with EM 2.1 API with one EXCEPTION:
  Introducing the new 'em_pool_cfg_t::align_offset{}' option into the existing
  em_pool_conf_t structure is potentially dangerous if these new fields are not
  initialized properly. Initializing the whole em_pool_cfg_t to '0' with memset
  before use is safe and equals API 2.1 behaviour.

1. Pool option to set the event payload alignment offset:
   Add the new 'em_pool_cfg_t::align_offset{}' option to be able to set the
   needed payload alignment offset per pool (during EM pool creation with
   em_pool_create(..., pool_cfg)).
   Setting 'align_offset.in_use = 0' disables the pool-specific alignment offset
   and equals API 2.1 behaviour.
   See the documentation for em_pool_cfg_t for a thorough explanation.
2. Timer option to use an external timer clock source:
   Add the em_timer_clksrc_t::EM_TIMER_CLKSRC_EXT option.
   Also add the EM_TIMER_CLKSRC_CPU option to explicitly request using the
   CPU clock as the timer clock source (behaviour is the same as using
   EM_TIMER_CLKSRC_DEFAULT).

--------------------------------------------------------------------------------
API 2.1 (EM_API_VERSION_MAJOR=2, EM_API_VERSION_MINOR=1)
--------------------------------------------------------------------------------
  Backwards compatible with EM 2.0 API with one EXCEPTION:
  All fields of em_conf_t given to em_init() should be intialized properly
  (inludes the new em_conf_t::api_hooks field).

 1. EO-start buffering of sent events changed to apply only to scheduled queues:
    Events sent to scheduled queues from an EO-start function are buffered.
    The buffered events will be sent into the queues when the EO-start
    functions have returned - otherwise it would not be possible to send events
    to the EO's own queues as the EO is not yet in a started state. No buffering
    is done when sending to queues that are not scheduled.
    See include/event_machine/api/event_machine_eo.h
 2. EM API-callback hooks:
    EM API-callback hook functions can be registered for a selected set of
    EM APIs. The EM APIs in question are mostly fast path APIs, like em_send(),
    em_alloc() and em_free(). Control APIs generally do not need hook support.
    A registered user provided hook function will be called by EM each time the
    corresponding API is called.
    API-callback hooks enables the user to gather statistics, trace program and
    event flow etc. API hooks should not change the state of the events etc.
    they receive as arguments, nor should they call the same API from within the
    hook to avoid hook recursion.
    Hook support is only available when EM_API_HOOKS_ENABLE != 0.
    Currently hook functions can be registered/unregistered with:
      em_hooks_register_alloc() and em_hooks_unregister_alloc()
      em_hooks_register_free() and em_hooks_unregister_free()
      em_hooks_register_send() and em_hooks_unregister_send()
    Hooks can also be registered during EM initialization by setting
    em_conf_t::api_hooks when calling em_init().
    Note: EM_API_HOOKS_ENABLE must be set to '1' to enable API-hooks (default=1)
    See include/event_machine/platform/event_machine_hooks.h
 3. EM pool info and statistics:
    em_pool_info() - retieve information about an EM event pool
    em_pool_info_print() - print EM Pool information for a given event pool
    em_pool_info_print_all() - print EM Pool information for all event pools.
    Note: Set EM config file: pool.statistics_enable=true to enable event pool
    statistics to ge gathered (default: false), otherwise only basic info is
    output omitting pool usage information.
    See include/event_machine/platform/event_machine_pool.h

--------------------------------------------------------------------------------
API 2.0 (EM_API_VERSION_MAJOR=2, EM_API_VERSION_MINOR=0)
--------------------------------------------------------------------------------
 1. Introducing local queues for fast pipelining: EM_QUEUE_TYPE_LOCAL
    Local queues are special virtual queues bypassing the scheduler for
    fast core-local pipelining without load balancing or atomic processing.
    Use em_sched_context_type_current() to determine the inherited scheduling
    context type (none, atomic or ordered) when handling events from a
    local queue.
    See event_machine_queue.h and event_machine_scheduler.h
 2. Introducing output queues for system specific implementation of SW-HW
    interfaces, e.g. towards packet output or accelerators: EM_QUEUE_TYPE_OUTPUT
    See event_machine_queue.h
 3. Added optional 'conf' argument also to atomic-group queue creation for
    attributes and platform specific configuration.
    See event_machine_atomic_group.h.
 4. Added optional 'conf' argument to EO start for passing configuration.
    See event_machine_eo.h.
 5. Added alternative synchronous (blocking) versions of "asynchronous
    API functions with notifications" to make it possible to do a simple robust
    startup & shutdown. The synchronous API-functions do not return until the
    operation has been fully completed on all cores (the asynchronous APIs with
    notifications might return while the operation is still ongoing, thus
    notifications should be used to signal completion).
    Synchronous APIs are named with the '_sync' ending:
        - em_eo_add_queue_sync()
        - em_eo_remove_queue_sync(),
        - em_eo_remove_queue_all_sync(), set arg 'delete_queues = true' to also
                                         delete all of the EO's queues.
        - em_eo_start_sync()
        - em_eo_stop_sync()
        - em_queue_group_create_sync()
        - em_queue_group_delete_sync()
        - em_queue_group_modify_sync()
    Note that the other cores must be running the dispatch loop when a core is
    calling a _sync() function, otherwise the _sync()-operation might never
    complete.
    See event_machine_eo.h and event_machine_queue_group.h.
 6. Simplified queue and EO management - Queue enable and disable is removed
    and handled implicitly by EO-add-queue or EO-remove-queue calls.
    See event_machine_queue.h and event_machine_eo.h.
 7. Events sent from within an EO-start function are buffered and sent
    after the start-operation has completed. Otherwise it would not be
    possible to reliably send events from the EO start-function to the
    EO's own queues.
 8. Added further _find() functions: atomic group, queue, EO and pool.
    Can be used to lookup objects by name.
 9. Added em_queue_current() and em_eo_current() to obtain the currently
    active queue or EO.
10. Added em_eo_get_context(eo) to return the EO context of an EO.
11. Added functions to iterate through all objects:
      - EOs & associated queues:
           - em_eo_get_first(), em_eo_get_next()
           - em_eo_queue_get_first(), em_eo_queue_get_next()
      - queue groups & associated queues:
           - em_queue_group_get_first(), em_queue_group_get_next()
           - em_queue_group_queue_get_first(), em_queue_group_queue_get_next()
      - atomic groups & associated queues:
          - em_atomic_group_get_first(), em_atomic_group_get_next()
          - em_atomic_group_queue_get_first(), em_atomic_group_queue_get_next()
      - queues:
          - em_queue_get_first(), em_queue_get_next()
      - event groups:
          - em_event_group_get_first(), em_event_group_get_next()
      - pools:
          - em_pool_get_first(), em_pool_get_next()
    See each header for details (_get_first(), _get_next())
12. Slight EM header file reorganization.
    - EM init&term APIs moved into their own header file:
      include/event_machine/platform/event_machine_init.h and
    - EM Event Pool APIs moved into their own header file:
      include/event_machine/platform/event_machine_pool.h
    - em_dispatch() moved into the 'dispatcher' API:
      include/event_machine/api/event_machine_dispatcher.h
    - em_event_pointer() moved into the 'event' API:
      include/event_machine/api/event_machine_event.h

This is a larger enhancement release with new or modified arguments requiring
changes to legacy code. All main features remain.

--------------------------------------------------------------------------------
API 1.4 (EM_API_VERSION_MAJOR=1, EM_API_VERSION_MINOR=4)
--------------------------------------------------------------------------------
1. Added an optional 'conf' argument to queue creation for attributes and
   platform specific configuration.
   See event_machine_queue.h.
2. Event Pool name added - event pools can be given a name during creation and
   that name can be used to find the event pool handle later.
   See event_machine_hw_specific.h.

--------------------------------------------------------------------------------
API 1.3 (EM_API_VERSION_MAJOR=1, EM_API_VERSION_MINOR=3)
--------------------------------------------------------------------------------
 1. Enhancement and clarification of ordered queue behavior. New clarified
    ordering concept is similar to what ODP currently defines. See queue
    documentation for details.
 2. Added add-ons - directory for extra APIs not part of the standard base
    definition. See README at add-ons/
 3. Clarification of event group behavior for exceptional situations. See
    event group documentation.
 4. New API to send multiple events (em_send_multi, em_send_group_multi) for
    potential performance gain.
 5. New API to receive multiple events from unscheduled queues.
 6. Event timer API (add-on). See add-ons/event_machine_timer.h
 7. Added API to change event type (if compatible). See event_machine_event.h
 8. UNDEF - values of -1 (FFFFFFFF) deprecated. Implementation should use
    value 0 for any UNDEF. This makes it safer to initialize data to 0.

Backwards compatible.

--------------------------------------------------------------------------------
API 1.2 (EM_API_VERSION_MAJOR=1, EM_API_VERSION_MINOR=2)
--------------------------------------------------------------------------------
 1. Introduced a slightly modified header structure (headers by service group).
    Application only needs to include event_machine.h. Event group is now also
    part of the standard API.
 2. Added possibility to explicitly signal end of event group handling,
    see em_event_group_processing_end()
 3. Added possibility to assign a received event to an event group,
    see em_event_group_assign()
 4. Added recovery to event groups,
    see em_event_group_abort(), em_event_group_get_notif()
 5. Added a hint to the scheduler, see em_preschedule()
 6. Added common dispatcher callbacks for debug, statistics or new services,
    see em_dispatch_register_enter_cb(), em_dispatch_unregister_enter_cb(),
        em_dispatch_register_exit_cb(),  em_dispatch_unregister_exit_cb()
 7. Added APIs for unscheduled queues along with a new queue type,
    see em_queue_dequeue(), EM_QUEUE_TYPE_UNSCHEDULED(arg to em_queue_create())
 8. Added API call to ask for the event size, see em_event_get_size()
 9. Added missing APIs to ask for the names of objects (like queue groups)
10. Clarified documentation

Backwards compatible.

--------------------------------------------------------------------------------
API 1.1 (EM_API_VERSION_MAJOR=1, EM_API_VERSION_MINOR=1)
--------------------------------------------------------------------------------
1. Atomic Group concept added (see event_machine_atomic_group.h)
2. Option to send notifications to an event group added.
   See declaration of em_notif_t (moved to event_machine_hw_types.h)
3. em_event_group_is_ready() added and
   clarified usage rules of em_event_group_apply()
4. Minor documentation clarifications

Backwards compatible with one EXCEPTION (item 2):
  Introducing a new input field to an existing structure is potentially
  dangerous to existing code behavior as it is not initialized unless the
  application initialized the structure with 0 using e.g. memset() with
  sizeof(em_notif_t).
  EM_EVENT_GROUP_UNDEF or value 0 as .egroup should cause the legacy behaviour
  in all implementations.

--------------------------------------------------------------------------------
API 1.0 (EM_API_VERSION_MAJOR=1, EM_API_VERSION_MINOR=0)
--------------------------------------------------------------------------------
Initial API
