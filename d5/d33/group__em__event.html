<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>EM-ODP: Events</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doc-stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="../../logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">EM-ODP
   &#160;<span id="projectnumber">3.8.0-1</span>
   </div>
   <div id="projectbrief">Event Machine on ODP</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('d5/d33/group__em__event.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Events</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d19/structem__event__uarea__info__t.html">em_event_uarea_info_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event user area information filled by <a class="el" href="../../d5/d33/group__em__event.html#gabd6f367cfeacc730b501eaafd3e8a8b7" title="Get the event user area information for a given event.">em_event_uarea_info()</a>  <a href="../../db/d19/structem__event__uarea__info__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d92/structem__event__vector__info__t.html">em_event_vector_info_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector event information filled by <a class="el" href="../../d5/d33/group__em__event.html#ga550bdc49ad729b59c9ff802a6cf7f809" title="Retrieve information about the given vector event.">em_event_vector_info()</a>  <a href="../../d5/d92/structem__event__vector__info__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga5f0e40f1b0b4892ee16aafe07ba4c90c"><td class="memItemLeft" align="right" valign="top">em_event_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga5f0e40f1b0b4892ee16aafe07ba4c90c">em_alloc</a> (uint32_t size, <a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a> type, em_pool_t pool)</td></tr>
<tr class="separator:ga5f0e40f1b0b4892ee16aafe07ba4c90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3256e7b651fe9e0cf5d3206d8e58f59d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga3256e7b651fe9e0cf5d3206d8e58f59d">em_alloc_multi</a> (em_event_t events[], int num, uint32_t size, <a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a> type, em_pool_t pool)</td></tr>
<tr class="separator:ga3256e7b651fe9e0cf5d3206d8e58f59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4f97ba217518d967f8078c56023c4d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free</a> (em_event_t event)</td></tr>
<tr class="separator:gad4f97ba217518d967f8078c56023c4d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga824c1dee097236d554918d6702431beb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga824c1dee097236d554918d6702431beb">em_free_multi</a> (em_event_t events[], int num)</td></tr>
<tr class="separator:ga824c1dee097236d554918d6702431beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaca4584a01b71429dfbb045342454b464"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send</a> (em_event_t event, em_queue_t queue)</td></tr>
<tr class="separator:gaca4584a01b71429dfbb045342454b464"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga272587cb3a55dd241332fd13b6e19054"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga272587cb3a55dd241332fd13b6e19054">em_send_multi</a> (const em_event_t events[], int num, em_queue_t queue)</td></tr>
<tr class="separator:ga272587cb3a55dd241332fd13b6e19054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8f701c3a5901fc81d922b9d1d02691e3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga8f701c3a5901fc81d922b9d1d02691e3">em_event_pointer</a> (em_event_t event)</td></tr>
<tr class="separator:ga8f701c3a5901fc81d922b9d1d02691e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c50f52f58029a31accc7e54c90a0bd1"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga1c50f52f58029a31accc7e54c90a0bd1">em_event_pointer_and_size</a> (em_event_t event, uint32_t *size)</td></tr>
<tr class="memdesc:ga1c50f52f58029a31accc7e54c90a0bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the event structure/data as well as the event size.  <a href="../../d5/d33/group__em__event.html#ga1c50f52f58029a31accc7e54c90a0bd1">More...</a><br /></td></tr>
<tr class="separator:ga1c50f52f58029a31accc7e54c90a0bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada9a8dda15cfef5cee0f99e4b6e63ba3"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#gada9a8dda15cfef5cee0f99e4b6e63ba3">em_event_get_size</a> (em_event_t event)</td></tr>
<tr class="separator:gada9a8dda15cfef5cee0f99e4b6e63ba3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d6d14d484e3496a6a19e1cc548128de"><td class="memItemLeft" align="right" valign="top">em_pool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga7d6d14d484e3496a6a19e1cc548128de">em_event_get_pool</a> (em_event_t event)</td></tr>
<tr class="memdesc:ga7d6d14d484e3496a6a19e1cc548128de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the EM event-pool the event was allocated from.  <a href="../../d5/d33/group__em__event.html#ga7d6d14d484e3496a6a19e1cc548128de">More...</a><br /></td></tr>
<tr class="separator:ga7d6d14d484e3496a6a19e1cc548128de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4220c91dcaa6c63ef78ecf021d385055"><td class="memItemLeft" align="right" valign="top">em_pool_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga4220c91dcaa6c63ef78ecf021d385055">em_event_get_pool_subpool</a> (em_event_t event, int *subpool)</td></tr>
<tr class="memdesc:ga4220c91dcaa6c63ef78ecf021d385055"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the EM event-pool and subpool the event was allocated from.  <a href="../../d5/d33/group__em__event.html#ga4220c91dcaa6c63ef78ecf021d385055">More...</a><br /></td></tr>
<tr class="separator:ga4220c91dcaa6c63ef78ecf021d385055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga91a1f77b8cd188c0d37cb1941a55f1b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga91a1f77b8cd188c0d37cb1941a55f1b1">em_event_set_type</a> (em_event_t event, <a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a> newtype)</td></tr>
<tr class="separator:ga91a1f77b8cd188c0d37cb1941a55f1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaab47111801094f57ba20c0bc1e8d3b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#gaaab47111801094f57ba20c0bc1e8d3b7">em_event_get_type</a> (em_event_t event)</td></tr>
<tr class="separator:gaaab47111801094f57ba20c0bc1e8d3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga737794b2272daa2c771db51bdf63184f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga737794b2272daa2c771db51bdf63184f">em_event_get_type_multi</a> (const em_event_t events[], int num, <a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a> types[])</td></tr>
<tr class="separator:ga737794b2272daa2c771db51bdf63184f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f4a335c1c16ed3dbae5689e614dc51b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga1f4a335c1c16ed3dbae5689e614dc51b">em_event_same_type_multi</a> (const em_event_t events[], int num, <a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a> *same_type)</td></tr>
<tr class="separator:ga1f4a335c1c16ed3dbae5689e614dc51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b0fa0ab1252e038328e0d63c0d4dc04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga6b0fa0ab1252e038328e0d63c0d4dc04">em_event_mark_send</a> (em_event_t event, em_queue_t queue)</td></tr>
<tr class="separator:ga6b0fa0ab1252e038328e0d63c0d4dc04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f9902e6d7b9d936a1c9b8a053176fea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga4f9902e6d7b9d936a1c9b8a053176fea">em_event_unmark_send</a> (em_event_t event)</td></tr>
<tr class="separator:ga4f9902e6d7b9d936a1c9b8a053176fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c90361d2e9f681a134e85ef8c4bb90b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga3c90361d2e9f681a134e85ef8c4bb90b">em_event_mark_free</a> (em_event_t event)</td></tr>
<tr class="memdesc:ga3c90361d2e9f681a134e85ef8c4bb90b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark the event as "free".  <a href="../../d5/d33/group__em__event.html#ga3c90361d2e9f681a134e85ef8c4bb90b">More...</a><br /></td></tr>
<tr class="separator:ga3c90361d2e9f681a134e85ef8c4bb90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62afa075f1510715b419d9a611f5ad4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga62afa075f1510715b419d9a611f5ad4f">em_event_unmark_free</a> (em_event_t event)</td></tr>
<tr class="memdesc:ga62afa075f1510715b419d9a611f5ad4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmark an event previously marked as "free" (i.e mark as "allocated" again).  <a href="../../d5/d33/group__em__event.html#ga62afa075f1510715b419d9a611f5ad4f">More...</a><br /></td></tr>
<tr class="separator:ga62afa075f1510715b419d9a611f5ad4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga64c03b2da94712d129be061e897b973c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga64c03b2da94712d129be061e897b973c">em_event_mark_free_multi</a> (const em_event_t events[], int num)</td></tr>
<tr class="memdesc:ga64c03b2da94712d129be061e897b973c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mark multiple events as "free".  <a href="../../d5/d33/group__em__event.html#ga64c03b2da94712d129be061e897b973c">More...</a><br /></td></tr>
<tr class="separator:ga64c03b2da94712d129be061e897b973c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69e1a4be4e88dc2038ecb0ff33d93e53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga69e1a4be4e88dc2038ecb0ff33d93e53">em_event_unmark_free_multi</a> (const em_event_t events[], int num)</td></tr>
<tr class="memdesc:ga69e1a4be4e88dc2038ecb0ff33d93e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmark multiple events previously marked as "free".  <a href="../../d5/d33/group__em__event.html#ga69e1a4be4e88dc2038ecb0ff33d93e53">More...</a><br /></td></tr>
<tr class="separator:ga69e1a4be4e88dc2038ecb0ff33d93e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga190e6e362cc404ce7cb08b98ad8dfa05"><td class="memItemLeft" align="right" valign="top">em_event_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga190e6e362cc404ce7cb08b98ad8dfa05">em_event_clone</a> (em_event_t event, em_pool_t pool)</td></tr>
<tr class="memdesc:ga190e6e362cc404ce7cb08b98ad8dfa05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone an event.  <a href="../../d5/d33/group__em__event.html#ga190e6e362cc404ce7cb08b98ad8dfa05">More...</a><br /></td></tr>
<tr class="separator:ga190e6e362cc404ce7cb08b98ad8dfa05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb07b7f80068324c89663dbe4e237e10"><td class="memItemLeft" align="right" valign="top">em_event_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#gabb07b7f80068324c89663dbe4e237e10">em_event_clone_part</a> (em_event_t event, em_pool_t pool, uint32_t offset, uint32_t len, bool clone_uarea)</td></tr>
<tr class="memdesc:gabb07b7f80068324c89663dbe4e237e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partially clone an event.  <a href="../../d5/d33/group__em__event.html#gabb07b7f80068324c89663dbe4e237e10">More...</a><br /></td></tr>
<tr class="separator:gabb07b7f80068324c89663dbe4e237e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cff0b1df08e1a2e97e2a75f97f61011"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga6cff0b1df08e1a2e97e2a75f97f61011">em_event_uarea_get</a> (em_event_t event, size_t *size)</td></tr>
<tr class="memdesc:ga6cff0b1df08e1a2e97e2a75f97f61011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the event user area, optionally along with its size.  <a href="../../d5/d33/group__em__event.html#ga6cff0b1df08e1a2e97e2a75f97f61011">More...</a><br /></td></tr>
<tr class="separator:ga6cff0b1df08e1a2e97e2a75f97f61011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25422e43f3983a207a0fdcebe1408c8e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga25422e43f3983a207a0fdcebe1408c8e">em_event_uarea_id_get</a> (em_event_t event, bool *isset, uint16_t *id)</td></tr>
<tr class="memdesc:ga25422e43f3983a207a0fdcebe1408c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the event user area ID along with information if it has been set.  <a href="../../d5/d33/group__em__event.html#ga25422e43f3983a207a0fdcebe1408c8e">More...</a><br /></td></tr>
<tr class="separator:ga25422e43f3983a207a0fdcebe1408c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88f96133b033dcdb8a6ffe1e9006a38b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga88f96133b033dcdb8a6ffe1e9006a38b">em_event_uarea_id_set</a> (em_event_t event, uint16_t id)</td></tr>
<tr class="memdesc:ga88f96133b033dcdb8a6ffe1e9006a38b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the event user area ID.  <a href="../../d5/d33/group__em__event.html#ga88f96133b033dcdb8a6ffe1e9006a38b">More...</a><br /></td></tr>
<tr class="separator:ga88f96133b033dcdb8a6ffe1e9006a38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd6f367cfeacc730b501eaafd3e8a8b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#gabd6f367cfeacc730b501eaafd3e8a8b7">em_event_uarea_info</a> (em_event_t event, <a class="el" href="../../db/d19/structem__event__uarea__info__t.html">em_event_uarea_info_t</a> *uarea_info)</td></tr>
<tr class="memdesc:gabd6f367cfeacc730b501eaafd3e8a8b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the event user area information for a given event.  <a href="../../d5/d33/group__em__event.html#gabd6f367cfeacc730b501eaafd3e8a8b7">More...</a><br /></td></tr>
<tr class="separator:gabd6f367cfeacc730b501eaafd3e8a8b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51187e913ac4ab0763dc75c1f2374da4"><td class="memItemLeft" align="right" valign="top">em_event_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga51187e913ac4ab0763dc75c1f2374da4">em_event_ref</a> (em_event_t event)</td></tr>
<tr class="separator:ga51187e913ac4ab0763dc75c1f2374da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c216518670a3bcbb1a8ae1d22e531e9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga8c216518670a3bcbb1a8ae1d22e531e9">em_event_has_ref</a> (em_event_t event)</td></tr>
<tr class="separator:ga8c216518670a3bcbb1a8ae1d22e531e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81aeca4166ada444ffd1af91dcfd692d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga81aeca4166ada444ffd1af91dcfd692d">em_event_vector_free</a> (em_event_t vector_event)</td></tr>
<tr class="memdesc:ga81aeca4166ada444ffd1af91dcfd692d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free the vector event only, not the events it contains.  <a href="../../d5/d33/group__em__event.html#ga81aeca4166ada444ffd1af91dcfd692d">More...</a><br /></td></tr>
<tr class="separator:ga81aeca4166ada444ffd1af91dcfd692d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fb6a529eae925f7e443eaba5212c938"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga1fb6a529eae925f7e443eaba5212c938">em_event_vector_tbl</a> (em_event_t vector_event, em_event_t **event_tbl)</td></tr>
<tr class="memdesc:ga1fb6a529eae925f7e443eaba5212c938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the event vector table from an event of (major) type EM_EVENT_TYPE_VECTOR.  <a href="../../d5/d33/group__em__event.html#ga1fb6a529eae925f7e443eaba5212c938">More...</a><br /></td></tr>
<tr class="separator:ga1fb6a529eae925f7e443eaba5212c938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8cb113c043cb04af9441d583d49278a6"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga8cb113c043cb04af9441d583d49278a6">em_event_vector_size</a> (em_event_t vector_event)</td></tr>
<tr class="memdesc:ga8cb113c043cb04af9441d583d49278a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of event handles available (set) in a vector.  <a href="../../d5/d33/group__em__event.html#ga8cb113c043cb04af9441d583d49278a6">More...</a><br /></td></tr>
<tr class="separator:ga8cb113c043cb04af9441d583d49278a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae1ef08cc9d533f86bd6dd88de2fe603"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#gaae1ef08cc9d533f86bd6dd88de2fe603">em_event_vector_size_set</a> (em_event_t vector_event, uint32_t size)</td></tr>
<tr class="memdesc:gaae1ef08cc9d533f86bd6dd88de2fe603"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the number of event handles stored in a vector.  <a href="../../d5/d33/group__em__event.html#gaae1ef08cc9d533f86bd6dd88de2fe603">More...</a><br /></td></tr>
<tr class="separator:gaae1ef08cc9d533f86bd6dd88de2fe603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49741fc83a9f4d8bafacee482112c20e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga49741fc83a9f4d8bafacee482112c20e">em_event_vector_max_size</a> (em_event_t vector_event)</td></tr>
<tr class="memdesc:ga49741fc83a9f4d8bafacee482112c20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum number of event handles that can be stored in a vector.  <a href="../../d5/d33/group__em__event.html#ga49741fc83a9f4d8bafacee482112c20e">More...</a><br /></td></tr>
<tr class="separator:ga49741fc83a9f4d8bafacee482112c20e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga550bdc49ad729b59c9ff802a6cf7f809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#ga550bdc49ad729b59c9ff802a6cf7f809">em_event_vector_info</a> (em_event_t vector_event, <a class="el" href="../../d5/d92/structem__event__vector__info__t.html">em_event_vector_info_t</a> *vector_info)</td></tr>
<tr class="memdesc:ga550bdc49ad729b59c9ff802a6cf7f809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve information about the given vector event.  <a href="../../d5/d33/group__em__event.html#ga550bdc49ad729b59c9ff802a6cf7f809">More...</a><br /></td></tr>
<tr class="separator:ga550bdc49ad729b59c9ff802a6cf7f809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac779a6a47891353edf77d21cd23c32f1"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/d33/group__em__event.html#gac779a6a47891353edf77d21cd23c32f1">em_event_to_u64</a> (em_event_t event)</td></tr>
<tr class="separator:gac779a6a47891353edf77d21cd23c32f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Operations on an event.</p>
<p>All application processing is driven by events in the Event Machine. An event describes a piece of work or data to be processed. The structure of an event is implementation and event type specific: it may be a directly accessible buffer of memory, packet headers and data, a vector or user specified content etc.</p>
<p>Applications use the event type to interpret the event structure. The event type consists of a major and a minor part: the major part specifies the actual type or structure of the event (sw buf, packet, vector etc.) while the minor part is user specific and can be used to distinguish between different use cases of the event.</p>
<p>Events follow message passing semantics: an event has to be allocated using the provided API (<a class="el" href="../../d5/d33/group__em__event.html#ga5f0e40f1b0b4892ee16aafe07ba4c90c">em_alloc()</a>) or received through queues by an EO callback function after which the event is owned by the application. Event ownership is transferred back to the system by using <a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send()</a> or <a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free()</a>. An event not owned by the application must not be touched.</p>
<p>The event handle, of type em_event_t, is not a direct pointer to the event structure, hence EM API functions must be used to get access to the contained data: for events of (major) type sw buffer or packet use <a class="el" href="../../d5/d33/group__em__event.html#ga8f701c3a5901fc81d922b9d1d02691e3">em_event_pointer()</a> while for vector events the contained array of event handles must be accessed with <a class="el" href="../../d5/d33/group__em__event.html#ga1fb6a529eae925f7e443eaba5212c938" title="Get the event vector table from an event of (major) type EM_EVENT_TYPE_VECTOR.">em_event_vector_tbl()</a> instead. Use the (major part of the) event type to distinguish between vectors and other types of events.</p>
<h3>Event References</h3>
<p>Normally, each event is associated with one event handle (em_event_t) - each event allocation produces a new event (and associated payload data) that can be processed, sent or freed. When the user EO has allocated or received an event from a queue, the event payload data may be read and written as needed by the application. An exception to the above described scenario happens when using event references. An event reference is an additional event handle referring to an existing event. New references are created with the <a class="el" href="../../d5/d33/group__em__event.html#ga51187e913ac4ab0763dc75c1f2374da4">em_event_ref()</a> API call. The intent of using multiple references is to avoid event copies. An event that has multiple references shares its data with the other reference handles and thus the (shared) data must not be modified. Reading event data from a reference is allowed. Writes to the event data must only be done when there is a single event handle left, i.e. when em_event_has_ref(event) returns 'false'. Results are undefined if these restrictions are not observed. The event is freed when the last reference, including the original event, is freed. It is not allowed to use event references with event groups since assigning an event that has references to an event group would assign all the references to the event group resulting in undefined behaviour. E.g. using <a class="el" href="../../d8/d4c/group__em__event__group.html#gab1ecab5cd71642d3909ffb6a907fd9a5">em_send_group()</a>/em_send_group_multi() to send a reference is wrong.</p>
<h3>Event User Area</h3>
<p>Additionally, an event may contain a user area separate from the event payload. The size of the event user area is set when creating the event pool from which the event is allocated. The user area is a fixed size (per pool) data area into which event related state data can be stored without having to access and change the payload. Note that the size of the event user area can be zero(0), depending on event pool configuration. Note also that the user area content is not initialized by EM, neither <a class="el" href="../../d5/d33/group__em__event.html#ga5f0e40f1b0b4892ee16aafe07ba4c90c">em_alloc()</a> nor <a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free()</a> will touch it and thus it might contain old user data set the last time the area was used during a previous allocation of the same event. Since the user area is not part of the event payload, it will not be transmitted as part of a packet etc. A user area ID can further be used to identify the user area contents. The event user area ID is stored outside of the user area itself and is thus always available, even if the size of the user area data is set to zero(0). See <a class="el" href="../../d1/d85/group__em__pool.html#ga05acc37c035cef81910e8ea77e5db158">em_pool_create()</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga6cff0b1df08e1a2e97e2a75f97f61011" title="Get a pointer to the event user area, optionally along with its size.">em_event_uarea_get()</a>, em_event_uarea_id_get/set() and <a class="el" href="../../d5/d33/group__em__event.html#gabd6f367cfeacc730b501eaafd3e8a8b7" title="Get the event user area information for a given event.">em_event_uarea_info()</a> for more information on the event user area and its associated ID.</p>
<h3>Vector Events</h3>
<p>Event (major) Type: EM_EVENT_TYPE_VECTOR</p>
<p>Vector events contain a table of events. All events in the event-table must be of major type EM_EVENT_TYPE_PACKET. Storing events of another type into the event-table is an error and leads to undefined behaviour. Event vector pools are created with <a class="el" href="../../d1/d85/group__em__pool.html#ga05acc37c035cef81910e8ea77e5db158">em_pool_create()</a> with the pool event-type set to EM_EVENT_TYPE_VECTOR. Event vectors can then be allocated from vector pools by calling em_alloc(..., vector_pool). To free the vector event along with all events it contains, use <a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free()</a> or <a class="el" href="../../d5/d33/group__em__event.html#ga824c1dee097236d554918d6702431beb">em_free_multi()</a>. To free the vector event only, not the events it contains, use <a class="el" href="../../d5/d33/group__em__event.html#ga81aeca4166ada444ffd1af91dcfd692d" title="Free the vector event only, not the events it contains.">em_event_vector_free()</a>. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga5f0e40f1b0b4892ee16aafe07ba4c90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5f0e40f1b0b4892ee16aafe07ba4c90c">&#9670;&nbsp;</a></span>em_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_event_t em_alloc </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">em_pool_t&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate an event.</p>
<p>Allocate a new event from the given pool. The pool used must support events of the requested (major) type:</p><ul>
<li>Events of (major) type EM_EVENT_TYPE_SW can be allocated from pools created to support event types EM_EVENT_TYPE_SW or EM_EVENT_TYPE_PACKET.</li>
<li>Events of (major) type EM_EVENT_TYPE_PACKET can be allocated from pools created to support the event type EM_EVENT_TYPE_PACKET.</li>
<li>Event vectors of (major) type EM_EVENT_TYPE_VECTOR can be allocated from pools created to support the event type EM_EVENT_TYPE_VECTOR.</li>
</ul>
<p>The memory address of the allocated event is system specific and can depend on the given pool, event size and type. The returned event (handle) may refer to a memory buffer, packet or vector etc., i.e. the event structure is event type specific.</p>
<p>Use <a class="el" href="../../d5/d33/group__em__event.html#ga8f701c3a5901fc81d922b9d1d02691e3">em_event_pointer()</a>, or for vectors <a class="el" href="../../d5/d33/group__em__event.html#ga1fb6a529eae925f7e443eaba5212c938" title="Get the event vector table from an event of (major) type EM_EVENT_TYPE_VECTOR.">em_event_vector_tbl()</a>, to convert an event (handle) to a pointer to the event payload or access the vector table. EM does not initialize the payload data.</p>
<p>Concerning events and pools of type EM_EVENT_TYPE_SW or EM_EVENT_TYPE_PACKET:</p><ul>
<li>EM_EVENT_TYPE_SW with minor type '0' is reserved for direct portability - it is always guaranteed to produce an event with contiguous payload that can directly be used by the application up to the given size (no HW specific descriptors etc. are visible). This event payload will be 64-bit aligned by default (unless explicitly configured otherwise).</li>
<li>EM_POOL_DEFAULT can be used as a pool handle if there's no need to use a specific event pool (up to the size- or event limits of that pool).</li>
</ul>
<p>Additionally it is guaranteed, that two separate buffers never share a cache line (to avoid false sharing).</p>
<dl class="section note"><dt>Note</dt><dd>Vector events must always have their major event type set to EM_EVENT_TYPE_VECTOR or EM will not recognize them as vectors. Also, the event type for periodic timer ring events, EM_EVENT_TYPE_TIMER_IND, must NOT be used with <a class="el" href="../../d5/d33/group__em__event.html#ga5f0e40f1b0b4892ee16aafe07ba4c90c">em_alloc()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>1) Packet &amp; sw-buf: event size in bytes (B), size &gt; 0. 2) Vector: number of event handles that should fit into the vector table of the event, size &gt; 0. </td></tr>
    <tr><td class="paramname">type</td><td>Event type to allocate. The event major-type must be supported by given 'pool'. Vector events must be allocated with major type EM_EVENT_TYPE_VECTOR from a pool created to support vectors. </td></tr>
    <tr><td class="paramname">pool</td><td>Event pool handle. The pool must have been created to support events of type 'em_event_type_major(type)'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated event or EM_EVENT_UNDEF on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free()</a>, <a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send()</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga8f701c3a5901fc81d922b9d1d02691e3">em_event_pointer()</a>, <a class="el" href="../../d8/d5f/group__em__eo.html#ga63161b6f46fb08a1708bad6c1fde2622">em_receive_func_t</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga190e6e362cc404ce7cb08b98ad8dfa05" title="Clone an event.">em_event_clone()</a> etc. </dd>
<dd>
additionally for vector events: <a class="el" href="../../d5/d33/group__em__event.html#ga1fb6a529eae925f7e443eaba5212c938" title="Get the event vector table from an event of (major) type EM_EVENT_TYPE_VECTOR.">em_event_vector_tbl()</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga81aeca4166ada444ffd1af91dcfd692d" title="Free the vector event only, not the events it contains.">em_event_vector_free()</a> etc. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d9/d8c/api_hooks_8c-example.html#a24">api_hooks.c</a>, <a class="el" href="../../dd/d24/atomic_processing_end_8c-example.html#a23">atomic_processing_end.c</a>, <a class="el" href="../../d5/d1d/bench_event_8c-example.html#a36">bench_event.c</a>, <a class="el" href="../../de/d3a/bench_pool_8c-example.html#a25">bench_pool.c</a>, <a class="el" href="../../d9/d6a/dispatcher_callback_8c-example.html#a34">dispatcher_callback.c</a>, <a class="el" href="../../d9/d32/error_8c-example.html#a23">error.c</a>, <a class="el" href="../../d5/d77/event_group_8c-example.html#a26">event_group.c</a>, <a class="el" href="../../d0/dba/event_group_abort_8c-example.html#a6">event_group_abort.c</a>, <a class="el" href="../../da/daa/event_group_assign_end_8c-example.html#a21">event_group_assign_end.c</a>, <a class="el" href="../../d4/d81/event_group_chaining_8c-example.html#a26">event_group_chaining.c</a>, <a class="el" href="../../d1/d25/fractal_8c-example.html#a32">fractal.c</a>, <a class="el" href="../../d5/dfc/hello_8c-example.html#a32">hello.c</a>, <a class="el" href="../../db/dee/loop_8c-example.html#a20">loop.c</a>, <a class="el" href="../../d3/d14/loop_refs_8c-example.html#a20">loop_refs.c</a>, <a class="el" href="../../d7/d6f/loop_united_8c-example.html#a12">loop_united.c</a>, <a class="el" href="../../d9/d33/loop_vectors_8c-example.html#a30">loop_vectors.c</a>, <a class="el" href="../../d4/d14/ordered_8c-example.html#a23">ordered.c</a>, <a class="el" href="../../d7/dbc/pairs_8c-example.html#a19">pairs.c</a>, <a class="el" href="../../db/d68/pool_perf_8c-example.html#a6">pool_perf.c</a>, <a class="el" href="../../d8/dc3/queue_group_8c-example.html#a29">queue_group.c</a>, <a class="el" href="../../d6/dd3/queue_groups_8c-example.html#a36">queue_groups.c</a>, <a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a41">queue_types_ag.c</a>, <a class="el" href="../../db/dcf/queue_types_local_8c-example.html#a36">queue_types_local.c</a>, <a class="el" href="../../d6/d76/queues_8c-example.html#a24">queues.c</a>, <a class="el" href="../../d0/d69/queues_local_8c-example.html#a24">queues_local.c</a>, <a class="el" href="../../d3/d64/queues_output_8c-example.html#a31">queues_output.c</a>, <a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a30">queues_unscheduled.c</a>, <a class="el" href="../../dd/d3c/scheduling_latency_8c-example.html#a35">scheduling_latency.c</a>, <a class="el" href="../../de/daa/send_multi_8c-example.html#a28">send_multi.c</a>, <a class="el" href="../../d5/dfe/timer_hello_8c-example.html#a31">timer_hello.c</a>, <a class="el" href="../../dd/d10/timer_test_8c-example.html#a38">timer_test.c</a>, <a class="el" href="../../d5/d57/timer_test_periodic_8c-example.html#a8">timer_test_periodic.c</a>, and <a class="el" href="../../d6/d5d/timer_test_ring_8c-example.html#a82">timer_test_ring.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00033">33</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga3256e7b651fe9e0cf5d3206d8e58f59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3256e7b651fe9e0cf5d3206d8e58f59d">&#9670;&nbsp;</a></span>em_alloc_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int em_alloc_multi </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">em_pool_t&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate multiple events.</p>
<p>Similar to <a class="el" href="../../d5/d33/group__em__event.html#ga5f0e40f1b0b4892ee16aafe07ba4c90c">em_alloc()</a>, but allows allocation of multiple events, with same properties, with one function call. The <a class="el" href="../../d5/d33/group__em__event.html#ga3256e7b651fe9e0cf5d3206d8e58f59d">em_alloc_multi()</a> API function will try to allocate the requested number ('num') of events but may fail to do so, e.g. if the pool has run out of events, and will return the actual number of events that were successfully allocated from the given pool.</p>
<dl class="section note"><dt>Note</dt><dd>Vector events must always have their major event type set to EM_EVENT_TYPE_VECTOR or EM will not recognize them as vectors. Also, the event type for periodic timer ring events, EM_EVENT_TYPE_TIMER_IND, must NOT be used with <a class="el" href="../../d5/d33/group__em__event.html#ga3256e7b651fe9e0cf5d3206d8e58f59d">em_alloc_multi()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">events</td><td>Output event array, events are allocated and filled by <a class="el" href="../../d5/d33/group__em__event.html#ga3256e7b651fe9e0cf5d3206d8e58f59d">em_alloc_multi()</a>. The given array must fit 'num' events. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of events to allocate and write into 'events[]' </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>1) Packet &amp; sw-buf: event size in bytes (B), size &gt; 0. 2) Vector: number of event handles that should fit into the vector table of the event, size &gt; 0. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">type</td><td>Event type to allocate. The event major-type must be supported by given 'pool'. Vector events must be allocated with major type EM_EVENT_TYPE_VECTOR from a pool created to support vectors. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">pool</td><td>Event pool handle. The pool must have been created to support events of type 'em_event_type_major(type)'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of events actually allocated from the pool (0 ... num) and written into the output array 'events[]'.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#ga5f0e40f1b0b4892ee16aafe07ba4c90c">em_alloc()</a> for more documentation. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a32">bench_event.c</a>, <a class="el" href="../../d9/d22/loop_multircv_8c-example.html#a25">loop_multircv.c</a>, <a class="el" href="../../d7/d6f/loop_united_8c-example.html#a17">loop_united.c</a>, and <a class="el" href="../../db/d68/pool_perf_8c-example.html#a8">pool_perf.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00092">92</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga190e6e362cc404ce7cb08b98ad8dfa05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga190e6e362cc404ce7cb08b98ad8dfa05">&#9670;&nbsp;</a></span>em_event_clone()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_event_t em_event_clone </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">em_pool_t&#160;</td>
          <td class="paramname"><em>pool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clone an event. </p>
<p>Allocate a new event with identical payload to the given event.</p>
<p>If present, the event user area is also cloned. Note that if a 'pool' is given and it has been configured to provide a smaller user area for events than the pool the original event was allocated from, then the clone operation will fail, returning EM_EVENT_UNDEF. Thus make sure to use compatible pools for cloning. Using the same pool ('pool' == EM_POOL_UNDEF) will always be compatible with respect of the user area sizing.</p>
<dl class="section note"><dt>Note</dt><dd>Other event metadata, internal headers and state are <em>NOT</em> cloned (e.g. the event-group of a cloned event is EM_EVENT_GROUP_UNDEF etc).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event to be cloned, must be a valid event. </td></tr>
    <tr><td class="paramname">pool</td><td>Optional event pool to allocate the cloned event from. Use 'EM_POOL_UNDEF' to clone from the same pool as 'event' was allocated from. The event-type of 'event' must be suitable for allocation from 'pool' (e.g. EM_EVENT_TYPE_PACKET can not be allocated from a pool supporting only EM_EVENT_TYPE_SW) The user area size of events from 'pool' must be large enough to fit the cloned user area.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The cloned event or EM_EVENT_UNDEF on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#ga5f0e40f1b0b4892ee16aafe07ba4c90c">em_alloc()</a>, <a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a53">bench_event.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01457">1457</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="gabb07b7f80068324c89663dbe4e237e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb07b7f80068324c89663dbe4e237e10">&#9670;&nbsp;</a></span>em_event_clone_part()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_event_t em_event_clone_part </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">em_pool_t&#160;</td>
          <td class="paramname"><em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clone_uarea</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Partially clone an event. </p>
<p>Allocate a new event (of size 'len') and copy 'len' bytes of data starting from 'offset' from the given event into the new event. The maximum number of bytes to copy is event-size minus the offset.</p>
<p>If present, and 'clone_uarea = true', the event user area is also cloned. Note that if a 'pool' is given and it has been configured to provide a smaller user area for events than the pool the original event was allocated from, then the clone operation will fail, returning EM_EVENT_UNDEF. Thus make sure to use compatible pools for cloning. Using the same pool ('pool' == EM_POOL_UNDEF) will always be compatible with respect of the user area sizing.</p>
<dl class="section note"><dt>Note</dt><dd>Other event metadata, internal headers and state are <em>NOT</em> cloned (e.g. the event-group of a cloned event is EM_EVENT_GROUP_UNDEF etc).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event to be cloned, must be a valid event. </td></tr>
    <tr><td class="paramname">pool</td><td>Optional event pool to allocate the partially cloned event from. Use 'EM_POOL_UNDEF' to clone from the same pool as 'event' was allocated from. The event-type of 'event' must be suitable for allocation from 'pool' (e.g. EM_EVENT_TYPE_PACKET can not be allocated from a pool supporting only EM_EVENT_TYPE_SW). The user area size of events from 'pool' must be large enough to fit the cloned user area (if 'clone_uarea = true'). </td></tr>
    <tr><td class="paramname">offset</td><td>Byte offset into the event payload </td></tr>
    <tr><td class="paramname">len</td><td>Number of bytes to copy/clone. </td></tr>
    <tr><td class="paramname">clone_uarea</td><td>Set 'true' to also clone the event user area (true/false).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The partially cloned event or EM_EVENT_UNDEF on error.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#ga5f0e40f1b0b4892ee16aafe07ba4c90c">em_alloc()</a>, <a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a54">bench_event.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01462">1462</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga7d6d14d484e3496a6a19e1cc548128de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7d6d14d484e3496a6a19e1cc548128de">&#9670;&nbsp;</a></span>em_event_get_pool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_pool_t em_event_get_pool </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the EM event-pool the event was allocated from. </p>
<p>The EM event-pool for the given event can only be obtained if the event has been allocated from a pool created with <a class="el" href="../../d1/d85/group__em__pool.html#ga05acc37c035cef81910e8ea77e5db158">em_pool_create()</a>. For other pools, e.g. external (to EM) pktio pools, EM_POOL_UNDEF is returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The EM event-pool handle or EM_POOL_UNDEF if no EM pool is found. EM_POOL_UNDEF is returned also for a valid event that has been allocated from a pool external to EM (no error is reported). </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a46">bench_event.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00876">876</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga4220c91dcaa6c63ef78ecf021d385055"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4220c91dcaa6c63ef78ecf021d385055">&#9670;&nbsp;</a></span>em_event_get_pool_subpool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_pool_t em_event_get_pool_subpool </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>subpool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the EM event-pool and subpool the event was allocated from. </p>
<p>Similar to <a class="el" href="../../d5/d33/group__em__event.html#ga7d6d14d484e3496a6a19e1cc548128de" title="Returns the EM event-pool the event was allocated from.">em_event_get_pool()</a>, but also outputs the subpool the event was allocated from. The subpool is in the range [0, EM_MAX_SUBPOOLS - 1].</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">event</td><td>Event handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">subpool</td><td>Subpool index, output arg filled on successful return. Use 'NULL' if not interested in the subpool (or prefer <a class="el" href="../../d5/d33/group__em__event.html#ga7d6d14d484e3496a6a19e1cc548128de" title="Returns the EM event-pool the event was allocated from.">em_event_get_pool()</a> instead). The subpool is filled only when a valid EM pool can be found, i.e. when the return value is other than EM_POOL_UNDEF - EM doesn't touch it otherwise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The EM event-pool handle or EM_POOL_UNDEF if no EM pool is found. EM_POOL_UNDEF is returned also for a valid event that has been allocated from a pool external to EM (no error is reported). </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a47">bench_event.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00899">899</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="gada9a8dda15cfef5cee0f99e4b6e63ba3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada9a8dda15cfef5cee0f99e4b6e63ba3">&#9670;&nbsp;</a></span>em_event_get_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t em_event_get_size </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the event payload size in bytes (B) of the given event</p>
<p>Returns the event type specific payload size of the event. For events of (major) type sw buf or packet the size is the available buffer/payload size in bytes (B).</p>
<dl class="section note"><dt>Note</dt><dd>Do not use this API function for vector events, instead use <a class="el" href="../../d5/d33/group__em__event.html#ga8cb113c043cb04af9441d583d49278a6" title="Number of event handles available (set) in a vector.">em_event_vector_size()</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga49741fc83a9f4d8bafacee482112c20e" title="Maximum number of event handles that can be stored in a vector.">em_event_vector_max_size()</a> or <a class="el" href="../../d5/d33/group__em__event.html#ga550bdc49ad729b59c9ff802a6cf7f809" title="Retrieve information about the given vector event.">em_event_vector_info()</a>. Use the event type to distinguish between vectors and other types of events.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Event type specific payload size in bytes. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a41">bench_event.c</a>, <a class="el" href="../../d6/d76/queues_8c-example.html#a39">queues.c</a>, <a class="el" href="../../d0/d69/queues_local_8c-example.html#a40">queues_local.c</a>, <a class="el" href="../../d3/d64/queues_output_8c-example.html#a53">queues_output.c</a>, <a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a33">queues_unscheduled.c</a>, and <a class="el" href="../../de/daa/send_multi_8c-example.html#a31">send_multi.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00818">818</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="gaaab47111801094f57ba20c0bc1e8d3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaab47111801094f57ba20c0bc1e8d3b7">&#9670;&nbsp;</a></span>em_event_get_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a> em_event_get_type </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the event type of an event</p>
<p>Returns the type of the given event. The type has been set by em_alloc...(), <a class="el" href="../../d5/d33/group__em__event.html#ga91a1f77b8cd188c0d37cb1941a55f1b1">em_event_set_type()</a> or e.g. packet input.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>event type, EM_EVENT_TYPE_UNDEF on error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#ga5f0e40f1b0b4892ee16aafe07ba4c90c">em_alloc()</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga91a1f77b8cd188c0d37cb1941a55f1b1">em_event_set_type()</a>, em_event_type_major(), em_event_type_minor(), em_receive_func_t(..., em_event_type_t type, ...) </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a42">bench_event.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00970">970</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga737794b2272daa2c771db51bdf63184f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga737794b2272daa2c771db51bdf63184f">&#9670;&nbsp;</a></span>em_event_get_type_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int em_event_get_type_multi </td>
          <td>(</td>
          <td class="paramtype">const em_event_t&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a>&#160;</td>
          <td class="paramname"><em>types</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the event types of multiple events</p>
<p>Writes the event type of each given event into an output type-array and returns the number of entries written. Note, if 'events[num]' are all of the same type then 'types[num]' will contain 'num' same entries.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">events</td><td>Event handles: events[num] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of events and output types. The array 'events[]' must contain 'num' entries and the output array 'types[]' must have room for 'num' entries. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">types</td><td>Event types (output array): types[num] (types[i] is the type of events[i])</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of event types (0...num) written into 'types[]'. The return value (always &gt;=0) is usually 'num' and thus '&lt;num' is only seen in error scenarios when the type of event[i] could not be obtained. The return value will be '0' in error cases or if the given 'num=0'. The function stops and returns on the first error and will not fill the rest of 'types[]'. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a43">bench_event.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00991">991</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga8c216518670a3bcbb1a8ae1d22e531e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c216518670a3bcbb1a8ae1d22e531e9">&#9670;&nbsp;</a></span>em_event_has_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool em_event_has_ref </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test if an event has references</p>
<p>An event that has multiple references share data with other events and thus the (shared) data must not be modified.</p>
<p>New references are created with the <a class="el" href="../../d5/d33/group__em__event.html#ga51187e913ac4ab0763dc75c1f2374da4">em_event_ref()</a> API call. The intent of multiple references is to avoid event copies. When a reference is created, this function returns 'true' for both events (i.e. for the original event and the new reference).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>This event has no references </td></tr>
    <tr><td class="paramname">true</td><td>The event has multiple references </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a51">bench_event.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01737">1737</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga3c90361d2e9f681a134e85ef8c4bb90b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c90361d2e9f681a134e85ef8c4bb90b">&#9670;&nbsp;</a></span>em_event_mark_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void em_event_mark_free </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark the event as "free". </p>
<p>Indicates a user-given promise to EM that the event will be freed back into the pool it was allocated from e.g. by HW or device drivers (external to EM). Calling <a class="el" href="../../d5/d33/group__em__event.html#ga3c90361d2e9f681a134e85ef8c4bb90b" title="Mark the event as &quot;free&quot;.">em_event_mark_free()</a> transfers event ownership away from the user, and thus the event must not be used or touched by the user anymore.</p>
<p>Example use case: A user provided output-callback function associated with a queue of type 'EM_QUEUE_TYPE_OUTPUT' can use this API when configuring a HW-device or device-driver to free the event (outside of EM) after transmission.</p>
<p>EM will, after this API-call, treat the event as "freed" and any further API operations or usage might lead to EM errors (depending on the error-check level), e.g. em_send/free/tmo_set/ack(event) etc. is forbidden after em_event_mark_free(event).</p>
<dl class="section note"><dt>Note</dt><dd>Registered API-callback hooks for em_free/_multi() (em_api_hook_free_t) will NOT be called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event to be marked as "free"</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free()</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga62afa075f1510715b419d9a611f5ad4f" title="Unmark an event previously marked as &quot;free&quot; (i.e mark as &quot;allocated&quot; again).">em_event_unmark_free()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01134">1134</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga64c03b2da94712d129be061e897b973c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga64c03b2da94712d129be061e897b973c">&#9670;&nbsp;</a></span>em_event_mark_free_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void em_event_mark_free_multi </td>
          <td>(</td>
          <td class="paramtype">const em_event_t&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mark multiple events as "free". </p>
<p>Similar to <a class="el" href="../../d5/d33/group__em__event.html#ga3c90361d2e9f681a134e85ef8c4bb90b" title="Mark the event as &quot;free&quot;.">em_event_mark_free()</a>, but allows the marking of multiple events as "free" with one function call.</p>
<dl class="section note"><dt>Note</dt><dd>Registered API-callback hooks for em_free/_multi() (em_api_hook_free_t) will NOT be called.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">events</td><td>Array of events to be marked as "free" </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>The number of events in the array 'events[]' </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01183">1183</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga6b0fa0ab1252e038328e0d63c0d4dc04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b0fa0ab1252e038328e0d63c0d4dc04">&#9670;&nbsp;</a></span>em_event_mark_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_event_mark_send </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">em_queue_t&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mark the event as "sent".</p>
<p>Indicates a user-given promise to EM that the event will later appear into 'queue' by some means other than an explicit user call to em_send...(). Calling <a class="el" href="../../d5/d33/group__em__event.html#ga6b0fa0ab1252e038328e0d63c0d4dc04">em_event_mark_send()</a> transfers event ownership away from the user, and thus the event must not be used or touched by the user anymore (the only exception is (hw) error recovery where the "sent" state can be cancelled by using <a class="el" href="../../d5/d33/group__em__event.html#ga4f9902e6d7b9d936a1c9b8a053176fea">em_event_unmark_send()</a> - dangerous!).</p>
<p>Example use case: A user provided output-callback function associated with a queue of type 'EM_QUEUE_TYPE_OUTPUT' can use this API when configuring a HW-device to deliver the event back into EM. The HW will eventually "send" the event and it will "somehow" again appear into EM for the user to process.</p>
<p>EM will, after this API-call, treat the event as "sent" and any further API operations or usage might lead to EM errors (depending on the error-check level), e.g. em_send/free/tmo_set/ack(event) etc. is forbidden after em_event_mark_send(event).</p>
<dl class="section note"><dt>Note</dt><dd>Registered API-callback hooks for em_send...() (em_api_hook_send_t) will NOT be called. </dd>
<dd>
Marking an event "sent" with an event group (corresponding to <a class="el" href="../../d8/d4c/group__em__event__group.html#gab1ecab5cd71642d3909ffb6a907fd9a5">em_send_group()</a>) is currently NOT supported.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event to be marked as "sent" </td></tr>
    <tr><td class="paramname">queue</td><td>Destination queue (must be scheduled, i.e. atomic, parallel or parallel-ordered)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_OK if successful</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send()</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga4f9902e6d7b9d936a1c9b8a053176fea">em_event_unmark_send()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01070">1070</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga8f701c3a5901fc81d922b9d1d02691e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8f701c3a5901fc81d922b9d1d02691e3">&#9670;&nbsp;</a></span>em_event_pointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* em_event_pointer </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the event structure/data.</p>
<p>Returns a pointer to the beginning of the event data or NULL in case of error. The structure/content of the event data is user and/or event type specific. It may be a directly accessible buffer of memory, contain packet headers and data or have user specified content etc. Use <a class="el" href="../../d5/d33/group__em__event.html#gaaab47111801094f57ba20c0bc1e8d3b7">em_event_get_type()</a> and em_event_type_major() to determine the type of the event.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#ga8f701c3a5901fc81d922b9d1d02691e3">em_event_pointer()</a> should NOT be used with events of (major) type EM_EVENT_TYPE_VECTOR or EM_EVENT_TYPE_TIMER_IND - usage with these types of events returns NULL and an error is reported. Instead, when dealing with event vectors, use <a class="el" href="../../d5/d33/group__em__event.html#ga1fb6a529eae925f7e443eaba5212c938" title="Get the event vector table from an event of (major) type EM_EVENT_TYPE_VECTOR.">em_event_vector_tbl()</a> to get access to the vector table. Further, periodic timer-ring timeout indication events have no user accessible payload.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the beginning of the event data </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on unsupported event type or other error</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#ga1fb6a529eae925f7e443eaba5212c938" title="Get the event vector table from an event of (major) type EM_EVENT_TYPE_VECTOR.">em_event_vector_tbl()</a> when dealing with vector events. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d9/d8c/api_hooks_8c-example.html#a27">api_hooks.c</a>, <a class="el" href="../../dd/d24/atomic_processing_end_8c-example.html#a26">atomic_processing_end.c</a>, <a class="el" href="../../d5/d1d/bench_event_8c-example.html#a38">bench_event.c</a>, <a class="el" href="../../d9/d6a/dispatcher_callback_8c-example.html#a37">dispatcher_callback.c</a>, <a class="el" href="../../d9/d32/error_8c-example.html#a26">error.c</a>, <a class="el" href="../../d5/d77/event_group_8c-example.html#a29">event_group.c</a>, <a class="el" href="../../d0/dba/event_group_abort_8c-example.html#a9">event_group_abort.c</a>, <a class="el" href="../../da/daa/event_group_assign_end_8c-example.html#a24">event_group_assign_end.c</a>, <a class="el" href="../../d4/d81/event_group_chaining_8c-example.html#a29">event_group_chaining.c</a>, <a class="el" href="../../d1/d25/fractal_8c-example.html#a34">fractal.c</a>, <a class="el" href="../../d5/dfc/hello_8c-example.html#a35">hello.c</a>, <a class="el" href="../../d4/d14/ordered_8c-example.html#a26">ordered.c</a>, <a class="el" href="../../db/d68/pool_perf_8c-example.html#a23">pool_perf.c</a>, <a class="el" href="../../d8/dc3/queue_group_8c-example.html#a32">queue_group.c</a>, <a class="el" href="../../d6/dd3/queue_groups_8c-example.html#a39">queue_groups.c</a>, <a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a57">queue_types_ag.c</a>, <a class="el" href="../../db/dcf/queue_types_local_8c-example.html#a39">queue_types_local.c</a>, <a class="el" href="../../d6/d76/queues_8c-example.html#a27">queues.c</a>, <a class="el" href="../../d0/d69/queues_local_8c-example.html#a27">queues_local.c</a>, <a class="el" href="../../d3/d64/queues_output_8c-example.html#a7">queues_output.c</a>, <a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a34">queues_unscheduled.c</a>, <a class="el" href="../../dd/d3c/scheduling_latency_8c-example.html#a39">scheduling_latency.c</a>, <a class="el" href="../../de/daa/send_multi_8c-example.html#a32">send_multi.c</a>, <a class="el" href="../../d5/dfe/timer_hello_8c-example.html#a34">timer_hello.c</a>, <a class="el" href="../../dd/d10/timer_test_8c-example.html#a41">timer_test.c</a>, <a class="el" href="../../d5/d57/timer_test_periodic_8c-example.html#a5">timer_test_periodic.c</a>, and <a class="el" href="../../d6/d5d/timer_test_ring_8c-example.html#a85">timer_test_ring.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00750">750</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga1c50f52f58029a31accc7e54c90a0bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c50f52f58029a31accc7e54c90a0bd1">&#9670;&nbsp;</a></span>em_event_pointer_and_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* em_event_pointer_and_size </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the event structure/data as well as the event size. </p>
<p>Returns a pointer to the beginning of the event data as well as the event type specific payload size via the output arg 'size'.</p>
<p>This API is a combination of <a class="el" href="../../d5/d33/group__em__event.html#ga8f701c3a5901fc81d922b9d1d02691e3">em_event_pointer()</a> and <a class="el" href="../../d5/d33/group__em__event.html#gada9a8dda15cfef5cee0f99e4b6e63ba3">em_event_get_size()</a> since both are often needed, especially in the EO-receive function where event payload manipulation naturally takes place.</p>
<p>The structure/content of the event data is user and/or event type specific. It may be a directly accessible buffer of memory, contain packet headers and data or have user specified content etc. Use <a class="el" href="../../d5/d33/group__em__event.html#gaaab47111801094f57ba20c0bc1e8d3b7">em_event_get_type()</a> to determine the type of the event or rely on the 'type' argument provided to the EO-receive function (em_receive_func_t). Use em_event_type_major() to get the major part of the event type.</p>
<dl class="section note"><dt>Note</dt><dd>Do not use this API function for vector events (major event type EM_EVENT_TYPE_VECTOR) or periodic timer ring timeout events (event type EM_EVENT_TYPE_TIMER_IND). Instead, for vectors use the em_event_vector_...() APIs. Timer ring timeout events have no user accessible data.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">event</td><td>Event handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Optional output arg into which the event type specific payload size (in bytes) is stored. Use 'size=NULL' if no size information is needed. Only set by the function when no errors occurred. For events of (major) type sw buf or packet the size is the available buffer/payload size in bytes (B).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the beginning of the event data </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on unsupported event type or other error ('size' not touched)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#ga8f701c3a5901fc81d922b9d1d02691e3">em_event_pointer()</a>, <a class="el" href="../../d5/d33/group__em__event.html#gada9a8dda15cfef5cee0f99e4b6e63ba3">em_event_get_size()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a39">bench_event.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00767">767</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga51187e913ac4ab0763dc75c1f2374da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51187e913ac4ab0763dc75c1f2374da4">&#9670;&nbsp;</a></span>em_event_ref()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">em_event_t em_event_ref </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a reference to an event</p>
<p>A reference is an additional event handle referring to an existing event. As long as an event has multiple references, none of them (including 'event') should be used to modify the event. Reading event data from a reference is allowed. Writes to the event data must only be done when there is a single event handle left, i.e. when em_event_has_ref(event) returns 'false'. Results are undefined if these restrictions are not observed.</p>
<p>The event is freed when the last reference, including the original event, is freed.</p>
<p>Currently only references to events of (major) type EM_EVENT_TYPE_PACKET can be created.</p>
<p>It is not allowed to use event references with event groups since assigning an event that has references to an event group would assign all the references to the event group resulting in undefined behaviour. E.g. using <a class="el" href="../../d8/d4c/group__em__event__group.html#gab1ecab5cd71642d3909ffb6a907fd9a5">em_send_group()</a>/em_send_group_multi() to send a reference is wrong.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event handle for which a reference is to be created.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Reference to the event </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EM_EVENT_UNDEF</td><td>on failure </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a52">bench_event.c</a>, <a class="el" href="../../d3/d14/loop_refs_8c-example.html#a23">loop_refs.c</a>, and <a class="el" href="../../d7/d6f/loop_united_8c-example.html#a15">loop_united.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01684">1684</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga1f4a335c1c16ed3dbae5689e614dc51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f4a335c1c16ed3dbae5689e614dc51b">&#9670;&nbsp;</a></span>em_event_same_type_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int em_event_same_type_multi </td>
          <td>(</td>
          <td class="paramtype">const em_event_t&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a> *&#160;</td>
          <td class="paramname"><em>same_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of events that have the same event type.</p>
<p>Returns the number of consecutive events from the start of the array 'events[]' that have the same event type. Outputs that same event type. Useful for iterating through an event-array and grouping by event type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">events</td><td>Event handles: events[num] </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>Number of events. The array 'events[]' must contain 'num' entries. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">same_type</td><td>Event type pointer for output</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of consecutive events (0...num) with the same event type (return value always &gt;=0), includes and starts from events[0]. The return value is usually '&gt;=1' and thus '0' is only seen in error scenarios when the type of the first event could not be obtained or if the given 'num=0'. The function stops and returns on the first error. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a44">bench_event.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01030">1030</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga91a1f77b8cd188c0d37cb1941a55f1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga91a1f77b8cd188c0d37cb1941a55f1b1">&#9670;&nbsp;</a></span>em_event_set_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_event_set_type </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a>&#160;</td>
          <td class="paramname"><em>newtype</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the event type of an event</p>
<p>The operation may fail if (the major part of) the new type is not compatible with the old one. EM does not check the compatibility of the new vs. old event type for all cases, thus the user must take care not to incorrectly update the type.</p>
<dl class="section note"><dt>Note</dt><dd>Vector events must always have their major type set to EM_EVENT_TYPE_VECTOR or EM will not recognize them as vectors. Also, timer ring events must always have their event type set to EM_EVENT_TYPE_TIMER_IND or EM will not recognize them as periodic timer ring timeout events. Trying to set an incorrect type for these events result in error.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event handle </td></tr>
    <tr><td class="paramname">newtype</td><td>New type for the event</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_OK on success</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#ga5f0e40f1b0b4892ee16aafe07ba4c90c">em_alloc()</a>, em_event_get_type/_multi(), em_event_type_major(), em_event_type_minor(), em_receive_func_t(..., em_event_type_t type, ...) </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a45">bench_event.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00923">923</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="gac779a6a47891353edf77d21cd23c32f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac779a6a47891353edf77d21cd23c32f1">&#9670;&nbsp;</a></span>em_event_to_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t em_event_to_u64 </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an event handle to an unsigned integer</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event handle to be converted </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>uint64_t value that can be used to print/display the handle</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This routine is intended to be used for diagnostic purposes to enable applications to e.g. generate a printable value that represents an em_event_t handle. </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01899">1899</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga6cff0b1df08e1a2e97e2a75f97f61011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cff0b1df08e1a2e97e2a75f97f61011">&#9670;&nbsp;</a></span>em_event_uarea_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* em_event_uarea_get </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the event user area, optionally along with its size. </p>
<p>The event user area is a fixed sized area located within the event metadata (i.e. outside of the event payload) that can be used to store application specific event related data without the need to adjust the payload. The event user area is configured during EM event pool creation and thus the size of the user area is set per pool.</p>
<p>Note that the user area content is not initialized by EM, neither <a class="el" href="../../d5/d33/group__em__event.html#ga5f0e40f1b0b4892ee16aafe07ba4c90c">em_alloc()</a> nor <a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free()</a> will touch it and thus it might contain old user data set the last time the area was used during a previous allocation of the same event. Since the user area is not part of the event payload, it will not be transmitted as part of a packet etc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">event</td><td>Event handle to get the user area of </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">size</td><td>Optional output arg into which the user area size is stored. Use 'size=NULL' if no size information is needed.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the event user area </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">NULL</td><td>on error or if the event contains no user area</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d85/group__em__pool.html#ga05acc37c035cef81910e8ea77e5db158">em_pool_create()</a> for pool specific configuration and the <a class="el" href="../../d2/d0c/group__EM.html">CLI (Command Line Interface) related</a> runtime config file em-odp.conf for the default value: 'pool.user_area_size'. </dd>
<dd>
<a class="el" href="../../d5/d33/group__em__event.html#gabd6f367cfeacc730b501eaafd3e8a8b7" title="Get the event user area information for a given event.">em_event_uarea_info()</a> if both user area ptr and ID is needed </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a40">bench_event.c</a>, and <a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a43">queue_types_ag.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01534">1534</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga25422e43f3983a207a0fdcebe1408c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga25422e43f3983a207a0fdcebe1408c8e">&#9670;&nbsp;</a></span>em_event_uarea_id_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_event_uarea_id_get </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>isset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the event user area ID along with information if it has been set. </p>
<p>The event user area can be associated with an optional ID that e.g. can be used to identify the contents of the actual user area data. The ID is stored outside of the actual user area data and is available for use even if the user area size has been set to zero(0) for the pool the event was allocated from.</p>
<p>This function is used to determine whether the user area ID has been set earlier and to retrieve the ID in the case it has been set. EM will initialize 'ID isset = false' when allocating a new event (indicating that the ID is not set). Use <a class="el" href="../../d5/d33/group__em__event.html#ga88f96133b033dcdb8a6ffe1e9006a38b" title="Set the event user area ID.">em_event_uarea_id_set()</a> to set the ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">event</td><td>Event handle to get the user area ID and "set"-status of </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">isset</td><td>Optional output arg: has the ID been set previously? At least one of 'isset' and 'id' must be given (or both). </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">id</td><td>Optional output arg into which the user area ID is stored if it has been set before. The output arg 'isset' should be used to determine whether 'id' has been set. Note: 'id' will not be touched if the ID has not been set earlier (i.e. when 'isset' is 'false'). At least one of 'isset' and 'id' must be given (or both).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_OK if successful</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#ga88f96133b033dcdb8a6ffe1e9006a38b" title="Set the event user area ID.">em_event_uarea_id_set()</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga6cff0b1df08e1a2e97e2a75f97f61011" title="Get a pointer to the event user area, optionally along with its size.">em_event_uarea_get()</a> </dd>
<dd>
<a class="el" href="../../d5/d33/group__em__event.html#gabd6f367cfeacc730b501eaafd3e8a8b7" title="Get the event user area information for a given event.">em_event_uarea_info()</a> if both user area ptr and ID is needed </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a48">bench_event.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01593">1593</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga88f96133b033dcdb8a6ffe1e9006a38b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88f96133b033dcdb8a6ffe1e9006a38b">&#9670;&nbsp;</a></span>em_event_uarea_id_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_event_uarea_id_set </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the event user area ID. </p>
<p>The event user area can be associated with an optional ID that e.g. can be used to identify the contents of the actual user area data. The ID is stored outside of the actual user area data and is available for use even if the user area size has been set to 0 for the pool the event was allocated from.</p>
<p>This function is used to set the event user area ID for the given event. The 'set' operation overwrites any ID stored earlier. Use <a class="el" href="../../d5/d33/group__em__event.html#ga25422e43f3983a207a0fdcebe1408c8e" title="Get the event user area ID along with information if it has been set.">em_event_uarea_id_get()</a> to check whether an ID has been set earlier and to retrieve the ID.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event handle for which to set the user area ID </td></tr>
    <tr><td class="paramname">id</td><td>The user area ID to set</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_OK if successful</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#ga25422e43f3983a207a0fdcebe1408c8e" title="Get the event user area ID along with information if it has been set.">em_event_uarea_id_get()</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga6cff0b1df08e1a2e97e2a75f97f61011" title="Get a pointer to the event user area, optionally along with its size.">em_event_uarea_get()</a>, <a class="el" href="../../d5/d33/group__em__event.html#gabd6f367cfeacc730b501eaafd3e8a8b7" title="Get the event user area information for a given event.">em_event_uarea_info()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a30">bench_event.c</a>, and <a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a44">queue_types_ag.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01571">1571</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="gabd6f367cfeacc730b501eaafd3e8a8b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd6f367cfeacc730b501eaafd3e8a8b7">&#9670;&nbsp;</a></span>em_event_uarea_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_event_uarea_info </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d19/structem__event__uarea__info__t.html">em_event_uarea_info_t</a> *&#160;</td>
          <td class="paramname"><em>uarea_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the event user area information for a given event. </p>
<p>Obtain information about the event user area for a certain given event. Information containing the user area pointer, size, as well as the ID is output via the 'uarea_info' struct. This API function combines the functionality of <a class="el" href="../../d5/d33/group__em__event.html#ga6cff0b1df08e1a2e97e2a75f97f61011" title="Get a pointer to the event user area, optionally along with its size.">em_event_uarea_get()</a> and <a class="el" href="../../d5/d33/group__em__event.html#ga25422e43f3983a207a0fdcebe1408c8e" title="Get the event user area ID along with information if it has been set.">em_event_uarea_id_get()</a> for use cases where both the user area pointer as well as the ID is needed. Calling one API function instead of two might be faster due to a fewer checks and internal conversions.</p>
<p>The event user area is a fixed sized area located within the event metadata (i.e. outside of the event payload) that can be used to store application specific event related data without the need to adjust the payload. The event user area is configured during EM event pool creation and thus the size of the user area is set per pool.</p>
<p>Note that the user area content is not initialized by EM, neither <a class="el" href="../../d5/d33/group__em__event.html#ga5f0e40f1b0b4892ee16aafe07ba4c90c">em_alloc()</a> nor <a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free()</a> will touch it and thus it might contain old user data set the last time the area was used during a previous allocation of the same event. Since the user area is not part of the event payload, it will not be transmitted as part of a packet etc.</p>
<p>The event user area can be associated with an optional ID that can be used to identify the contents of the actual user area data. The ID is stored outside of the actual user area data and is available for use even if the user area size has been set to zero(0) for the pool the event was allocated from. EM will initialize 'uarea_info.id.isset = false' when allocating a new event (indicating that the ID is not set).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">event</td><td>Event handle to get the user area information of. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">uarea_info</td><td>Output struct into which the user area information is stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM status code incidating success or failure of the operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EM_OK</td><td>Operation successful. </td></tr>
    <tr><td class="paramname">Other</td><td>Operation FAILED and no valid user area info could be obtained, 'uarea_info' is all NULL/zero(0) in this case.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d1/d85/group__em__pool.html#ga05acc37c035cef81910e8ea77e5db158">em_pool_create()</a> for pool specific configuration and the <a class="el" href="../../d2/d0c/group__EM.html">CLI (Command Line Interface) related</a> runtime config file em-odp.conf for the default value: 'pool.user_area_size'. </dd>
<dd>
<a class="el" href="../../d5/d33/group__em__event.html#ga6cff0b1df08e1a2e97e2a75f97f61011" title="Get a pointer to the event user area, optionally along with its size.">em_event_uarea_get()</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga25422e43f3983a207a0fdcebe1408c8e" title="Get the event user area ID along with information if it has been set.">em_event_uarea_id_get()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a50">bench_event.c</a>, and <a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a62">queue_types_ag.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01631">1631</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga62afa075f1510715b419d9a611f5ad4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62afa075f1510715b419d9a611f5ad4f">&#9670;&nbsp;</a></span>em_event_unmark_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void em_event_unmark_free </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmark an event previously marked as "free" (i.e mark as "allocated" again). </p>
<dl class="section note"><dt>Note</dt><dd>This is for recovery situations only and can potentially crash the application if used incorrectly! Unmarking the free-state of an event that has already been freed will lead to fatal error.</dd></dl>
<p>Revert an event's "free" state, as set by <a class="el" href="../../d5/d33/group__em__event.html#ga3c90361d2e9f681a134e85ef8c4bb90b" title="Mark the event as &quot;free&quot;.">em_event_mark_free()</a>, back to the state before the mark-free function call. Any further usage of the event after <a class="el" href="../../d5/d33/group__em__event.html#ga3c90361d2e9f681a134e85ef8c4bb90b" title="Mark the event as &quot;free&quot;.">em_event_mark_free()</a>, by EM or the user, will result in error when calling <a class="el" href="../../d5/d33/group__em__event.html#ga62afa075f1510715b419d9a611f5ad4f" title="Unmark an event previously marked as &quot;free&quot; (i.e mark as &quot;allocated&quot; again).">em_event_unmark_free()</a> since the state has become unrecoverable. =&gt; the only allowed EM API call after <a class="el" href="../../d5/d33/group__em__event.html#ga3c90361d2e9f681a134e85ef8c4bb90b" title="Mark the event as &quot;free&quot;.">em_event_mark_free()</a> (for a certain event) is <a class="el" href="../../d5/d33/group__em__event.html#ga62afa075f1510715b419d9a611f5ad4f" title="Unmark an event previously marked as &quot;free&quot; (i.e mark as &quot;allocated&quot; again).">em_event_unmark_free()</a> when it is certain that the event, due to some external error, will not be freed otherwise and must be recovered back into the EM-domain so that calling <a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free()</a> by the user is possible. Calling <a class="el" href="../../d5/d33/group__em__event.html#ga62afa075f1510715b419d9a611f5ad4f" title="Unmark an event previously marked as &quot;free&quot; (i.e mark as &quot;allocated&quot; again).">em_event_unmark_free()</a> transfers event ownership back to the user again.</p>
<dl class="section note"><dt>Note</dt><dd>Unmark-send and unmark-free are the only valid cases of using an event that the user no longer owns - all other such uses leads to fatal error</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> err;</div>
<div class="line">hw_err_t hw_err;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// &#39;event&#39; owned by the user</span></div>
<div class="line"><a class="code" href="../../d5/d33/group__em__event.html#ga3c90361d2e9f681a134e85ef8c4bb90b">em_event_mark_free</a>(event);</div>
<div class="line"><span class="comment">// &#39;event&#39; no longer owned by the user - don&#39;t touch!</span></div>
<div class="line"> </div>
<div class="line">hw_err = config_hw_to_transmit_event(...hw-cfg..., event);</div>
<div class="line"><span class="keywordflow">if</span> (hw_err) {</div>
<div class="line">   <span class="comment">// hw config error - the event can be recovered if it is</span></div>
<div class="line">   <span class="comment">// certain that the hw won&#39;t free that same event.</span></div>
<div class="line">   <span class="comment">// note: the user doesn&#39;t own the event here and actually</span></div>
<div class="line">   <span class="comment">//       uses an obsolete event handle to recover the event.</span></div>
<div class="line">   <a class="code" href="../../d5/d33/group__em__event.html#ga62afa075f1510715b419d9a611f5ad4f">em_event_unmark_free</a>(event);</div>
<div class="line">   <span class="comment">// &#39;event&#39; recovered, again owned by the user</span></div>
<div class="line">   <a class="code" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free</a>(event);</div>
<div class="line">}</div>
<div class="ttc" id="aevent__machine__types_8h_html_adddd88868f7aa0d32b3e40245eb4ef8f"><div class="ttname"><a href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a></div><div class="ttdeci">uint32_t em_status_t</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d11/event__machine__types_8h_source.html#l00321">event_machine_types.h:321</a></div></div>
<div class="ttc" id="agroup__em__event_html_ga3c90361d2e9f681a134e85ef8c4bb90b"><div class="ttname"><a href="../../d5/d33/group__em__event.html#ga3c90361d2e9f681a134e85ef8c4bb90b">em_event_mark_free</a></div><div class="ttdeci">void em_event_mark_free(em_event_t event)</div><div class="ttdoc">Mark the event as &quot;free&quot;.</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d32/event__machine__event_8c_source.html#l01134">event_machine_event.c:1134</a></div></div>
<div class="ttc" id="agroup__em__event_html_ga62afa075f1510715b419d9a611f5ad4f"><div class="ttname"><a href="../../d5/d33/group__em__event.html#ga62afa075f1510715b419d9a611f5ad4f">em_event_unmark_free</a></div><div class="ttdeci">void em_event_unmark_free(em_event_t event)</div><div class="ttdoc">Unmark an event previously marked as &quot;free&quot; (i.e mark as &quot;allocated&quot; again).</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d32/event__machine__event_8c_source.html#l01159">event_machine_event.c:1159</a></div></div>
<div class="ttc" id="agroup__em__event_html_gad4f97ba217518d967f8078c56023c4d4"><div class="ttname"><a href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free</a></div><div class="ttdeci">void em_free(em_event_t event)</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d32/event__machine__event_8c_source.html#l00261">event_machine_event.c:261</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event previously marked as "free" with em_event_mark_free/_multi(), any other usecase is invalid!</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free()</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga3c90361d2e9f681a134e85ef8c4bb90b" title="Mark the event as &quot;free&quot;.">em_event_mark_free()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01159">1159</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga69e1a4be4e88dc2038ecb0ff33d93e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69e1a4be4e88dc2038ecb0ff33d93e53">&#9670;&nbsp;</a></span>em_event_unmark_free_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void em_event_unmark_free_multi </td>
          <td>(</td>
          <td class="paramtype">const em_event_t&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmark multiple events previously marked as "free". </p>
<dl class="section note"><dt>Note</dt><dd>This is for recovery situations only and can potentially crash the application if used incorrectly!</dd></dl>
<p>Similar to <a class="el" href="../../d5/d33/group__em__event.html#ga62afa075f1510715b419d9a611f5ad4f" title="Unmark an event previously marked as &quot;free&quot; (i.e mark as &quot;allocated&quot; again).">em_event_unmark_free()</a>, but allows to do the "free"-unmarking of multiple events with one function call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">events</td><td>Events previously marked as "free" with em_event_mark_free/_multi(), any other usecase is invalid! </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>The number of events in the array 'events[]' </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01227">1227</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga4f9902e6d7b9d936a1c9b8a053176fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f9902e6d7b9d936a1c9b8a053176fea">&#9670;&nbsp;</a></span>em_event_unmark_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_event_unmark_send </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unmark an event previously marked as "sent" (i.e mark as "unsent")</p>
<dl class="section note"><dt>Note</dt><dd>This is for recovery situations only and can potentially crash the application if used incorrectly!</dd></dl>
<p>Revert an event's "sent" state, as set by <a class="el" href="../../d5/d33/group__em__event.html#ga6b0fa0ab1252e038328e0d63c0d4dc04">em_event_mark_send()</a>, back to the state before the mark-send function call. Any further usage of the event after <a class="el" href="../../d5/d33/group__em__event.html#ga6b0fa0ab1252e038328e0d63c0d4dc04">em_event_mark_send()</a>, by EM or the user, will result in error when calling <a class="el" href="../../d5/d33/group__em__event.html#ga4f9902e6d7b9d936a1c9b8a053176fea">em_event_unmark_send()</a> since the state has become unrecoverable. =&gt; the only allowed EM API call after <a class="el" href="../../d5/d33/group__em__event.html#ga6b0fa0ab1252e038328e0d63c0d4dc04">em_event_mark_send()</a> is <a class="el" href="../../d5/d33/group__em__event.html#ga4f9902e6d7b9d936a1c9b8a053176fea">em_event_unmark_send()</a> if it is certain that the event, due to some external error, will never be sent into EM again otherwise. Calling <a class="el" href="../../d5/d33/group__em__event.html#ga4f9902e6d7b9d936a1c9b8a053176fea">em_event_unmark_send()</a> transfers event ownership back to the user again.</p>
<dl class="section note"><dt>Note</dt><dd>Unmark-send and unmark-free are the only valid cases of using an event that the user no longer owns - all other such uses leads to fatal error</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> err;</div>
<div class="line">hw_err_t hw_err;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// &#39;event&#39; owned by the user</span></div>
<div class="line">err = <a class="code" href="../../d5/d33/group__em__event.html#ga6b0fa0ab1252e038328e0d63c0d4dc04">em_event_mark_send</a>(event, queue);</div>
<div class="line"><span class="keywordflow">if</span> (err != <a class="code" href="../../d4/d11/event__machine__types_8h.html#a03546e6a7e93665c52d479831e0a6dca">EM_OK</a>)</div>
<div class="line">   <span class="keywordflow">return</span> err; <span class="comment">// NOK</span></div>
<div class="line"><span class="comment">// &#39;event&#39; no longer owned by the user - don&#39;t touch!</span></div>
<div class="line"> </div>
<div class="line">hw_err = config_hw_to_send_event(...hw-cfg..., event, queue);</div>
<div class="line"><span class="keywordflow">if</span> (hw_err) {</div>
<div class="line">   <span class="comment">// hw config error - the event can be recovered if it is</span></div>
<div class="line">   <span class="comment">// certain that the hw won&#39;t send that same event.</span></div>
<div class="line">   <span class="comment">// note: the user doesn&#39;t own the event here and actually</span></div>
<div class="line">   <span class="comment">//       uses an obsolete event handle to recover the event.</span></div>
<div class="line">   err = <a class="code" href="../../d5/d33/group__em__event.html#ga4f9902e6d7b9d936a1c9b8a053176fea">em_event_unmark_send</a>(event);</div>
<div class="line">   <span class="keywordflow">if</span> (err != <a class="code" href="../../d4/d11/event__machine__types_8h.html#a03546e6a7e93665c52d479831e0a6dca">EM_OK</a>)</div>
<div class="line">           <span class="keywordflow">return</span> err; <span class="comment">// NOK</span></div>
<div class="line">   <span class="comment">// &#39;event&#39; recovered, again owned by the user</span></div>
<div class="line">   <a class="code" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free</a>(event);</div>
<div class="line">}</div>
<div class="ttc" id="aevent__machine__types_8h_html_a03546e6a7e93665c52d479831e0a6dca"><div class="ttname"><a href="../../d4/d11/event__machine__types_8h.html#a03546e6a7e93665c52d479831e0a6dca">EM_OK</a></div><div class="ttdeci">#define EM_OK</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d11/event__machine__types_8h_source.html#l00329">event_machine_types.h:329</a></div></div>
<div class="ttc" id="agroup__em__event_html_ga4f9902e6d7b9d936a1c9b8a053176fea"><div class="ttname"><a href="../../d5/d33/group__em__event.html#ga4f9902e6d7b9d936a1c9b8a053176fea">em_event_unmark_send</a></div><div class="ttdeci">em_status_t em_event_unmark_send(em_event_t event)</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d32/event__machine__event_8c_source.html#l01112">event_machine_event.c:1112</a></div></div>
<div class="ttc" id="agroup__em__event_html_ga6b0fa0ab1252e038328e0d63c0d4dc04"><div class="ttname"><a href="../../d5/d33/group__em__event.html#ga6b0fa0ab1252e038328e0d63c0d4dc04">em_event_mark_send</a></div><div class="ttdeci">em_status_t em_event_mark_send(em_event_t event, em_queue_t queue)</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d32/event__machine__event_8c_source.html#l01070">event_machine_event.c:1070</a></div></div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event previously marked as "sent" with <a class="el" href="../../d5/d33/group__em__event.html#ga6b0fa0ab1252e038328e0d63c0d4dc04">em_event_mark_send()</a>, any other case will be invalid!</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_OK if successful</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send()</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga6b0fa0ab1252e038328e0d63c0d4dc04">em_event_mark_send()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01112">1112</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga81aeca4166ada444ffd1af91dcfd692d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81aeca4166ada444ffd1af91dcfd692d">&#9670;&nbsp;</a></span>em_event_vector_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void em_event_vector_free </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>vector_event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Free the vector event only, not the events it contains. </p>
<p>Frees only the vector event itself and not the events it contains in its vector-table. To free the vector event along with all events it contains, use <a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free()</a> or <a class="el" href="../../d5/d33/group__em__event.html#ga824c1dee097236d554918d6702431beb">em_free_multi()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector_event</td><td>Vector event handle </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a55">bench_event.c</a>, and <a class="el" href="../../d9/d33/loop_vectors_8c-example.html#a43">loop_vectors.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01749">1749</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga550bdc49ad729b59c9ff802a6cf7f809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga550bdc49ad729b59c9ff802a6cf7f809">&#9670;&nbsp;</a></span>em_event_vector_info()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_event_vector_info </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>vector_event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d5/d92/structem__event__vector__info__t.html">em_event_vector_info_t</a> *&#160;</td>
          <td class="paramname"><em>vector_info</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve information about the given vector event. </p>
<p>Vector event information is output via the struct 'vector_info'. Combines the APIs <a class="el" href="../../d5/d33/group__em__event.html#ga1fb6a529eae925f7e443eaba5212c938" title="Get the event vector table from an event of (major) type EM_EVENT_TYPE_VECTOR.">em_event_vector_tbl()</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga8cb113c043cb04af9441d583d49278a6" title="Number of event handles available (set) in a vector.">em_event_vector_size()</a> and <a class="el" href="../../d5/d33/group__em__event.html#ga49741fc83a9f4d8bafacee482112c20e" title="Maximum number of event handles that can be stored in a vector.">em_event_vector_max_size()</a> into one API call.</p>
<p>All events in the event-table must be of major type EM_EVENT_TYPE_PACKET. Storing events of another type into the event-table is an error and leads to undefined behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">vector_event</td><td>Vector event handle to get the information of. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vector_info</td><td>Output struct into which the vector information is stored.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM status code incidating success or failure of the operation. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EM_OK</td><td>Operation successful. </td></tr>
    <tr><td class="paramname">Other</td><td>Operation FAILED and no valid vector info could be obtained, 'vector_info' is all NULL/zero(0) in this case. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a60">bench_event.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01859">1859</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga49741fc83a9f4d8bafacee482112c20e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49741fc83a9f4d8bafacee482112c20e">&#9670;&nbsp;</a></span>em_event_vector_max_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t em_event_vector_max_size </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>vector_event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum number of event handles that can be stored in a vector. </p>
<p>Returns the maximum number of events that can be stored into the event-table of the given vector event, i.e. the max-size that can be used with <a class="el" href="../../d5/d33/group__em__event.html#gaae1ef08cc9d533f86bd6dd88de2fe603" title="Set the number of event handles stored in a vector.">em_event_vector_size_set()</a>. The max-size might be larger than the size requested during allocation and instead reflects the vector-size used when creating the EM event vector pool.</p>
<p>All events in the event-table must be of major type EM_EVENT_TYPE_PACKET. Storing events of another type into the event-table is an error and leads to undefined behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector_event</td><td>Vector event handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The maximum number of event handles that can be stored in the vector </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">&gt;0</td><td>on success </td></tr>
    <tr><td class="paramname">0</td><td>on failure or if EM can't retrieve the max size (non-EM pool). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a58">bench_event.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01837">1837</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga8cb113c043cb04af9441d583d49278a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8cb113c043cb04af9441d583d49278a6">&#9670;&nbsp;</a></span>em_event_vector_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t em_event_vector_size </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>vector_event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of event handles available (set) in a vector. </p>
<p>Returns the number of available events in the vector. Note that the returned 'size' indicates how many valid events are stored in the vector's event-table. The 'size' neither indicates the alloc-size (size given to <a class="el" href="../../d5/d33/group__em__event.html#ga5f0e40f1b0b4892ee16aafe07ba4c90c">em_alloc()</a>) nor the max-size of the event-table, use em_event_vector_max_size/info() to obtain that information.</p>
<p>All events in the event-table must be of major type EM_EVENT_TYPE_PACKET. Storing events of another type into the event-table is an error and leads to undefined behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector_event</td><td>Vector event handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of event handles available (set) in the vector</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A newly allocated vector has an empty event-table and thus the returned size is zero until updated with <a class="el" href="../../d5/d33/group__em__event.html#gaae1ef08cc9d533f86bd6dd88de2fe603" title="Set the number of event handles stored in a vector.">em_event_vector_size_set()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a57">bench_event.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01799">1799</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="gaae1ef08cc9d533f86bd6dd88de2fe603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaae1ef08cc9d533f86bd6dd88de2fe603">&#9670;&nbsp;</a></span>em_event_vector_size_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void em_event_vector_size_set </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>vector_event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the number of event handles stored in a vector. </p>
<p>Update the number of event handles stored in a vector. This function shall be used to set the number of events available in the given vector when the application itself is producing (or updating) the event vector. Only valid event handles can be stored into the vector's event-table. The events must be stored into the vector before setting the size, i.e. first add/remove events to/from the vector's event-table (within max-size limits) and only after that set the size.</p>
<p>All events in the event-table must be of major type EM_EVENT_TYPE_PACKET. Storing events of another type into the event-table is an error and leads to undefined behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vector_event</td><td>Vector event handle </td></tr>
    <tr><td class="paramname">size</td><td>Number of event handles in the vector</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The maximum number of event handles the vector can hold is defined by <a class="el" href="../../d2/db5/structem__pool__cfg__t.html#aa67ebf1bba1e9239f2332030aaf39e2a">em_pool_cfg_t::subpool</a>[i].size or can be obtained for a specific vector with em_event_vector_max_size(vector_event).</dd>
<dd>
All handles in the vector table (0 ... size - 1) need to be valid event handles. </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a35">bench_event.c</a>, <a class="el" href="../../d7/d6f/loop_united_8c-example.html#a20">loop_united.c</a>, and <a class="el" href="../../d9/d33/loop_vectors_8c-example.html#a34">loop_vectors.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01818">1818</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga1fb6a529eae925f7e443eaba5212c938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1fb6a529eae925f7e443eaba5212c938">&#9670;&nbsp;</a></span>em_event_vector_tbl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t em_event_vector_tbl </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>vector_event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">em_event_t **&#160;</td>
          <td class="paramname"><em>event_tbl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the event vector table from an event of (major) type EM_EVENT_TYPE_VECTOR. </p>
<p>The event vector table is an array of event handles (em_event_t) stored in a contiguous memory location for events with major event type set to EM_EVENT_TYPE_VECTOR. Upon completion of this API, this function returns the event table pointer of the given vector event via the output argument 'event_tbl'.</p>
<p>All events in the event-table must be of major type EM_EVENT_TYPE_PACKET. Storing events of another type into the event-table is an error and leads to undefined behaviour.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">vector_event</td><td>Vector event handle </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">event_tbl</td><td>Pointer into which the event table (ptr) is written</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of event handles available (set) in the vector event.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>A newly allocated vector has an empty event-table and thus the returned size is zero until updated with <a class="el" href="../../d5/d33/group__em__event.html#gaae1ef08cc9d533f86bd6dd88de2fe603" title="Set the number of event handles stored in a vector.">em_event_vector_size_set()</a>.</dd></dl>
<div class="fragment"><div class="line"><a class="code" href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a> event_type = <a class="code" href="../../d5/d33/group__em__event.html#gaaab47111801094f57ba20c0bc1e8d3b7">em_event_get_type</a>(vector_event);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">if</span> (em_event_type_major(event_type) == <a class="code" href="../../d0/d07/event__machine__hw__types_8h.html#ace0fe27049350469ff1be8188acfea89ab08afd6a4a38ec98dae5d58f064b8018">EM_EVENT_TYPE_VECTOR</a>) {</div>
<div class="line">   em_event_t *event_tbl;</div>
<div class="line">   uint32_t num = <a class="code" href="../../d5/d33/group__em__event.html#ga1fb6a529eae925f7e443eaba5212c938">em_event_vector_tbl</a>(vector_event, &amp;event_tbl);</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">if</span> (!num)</div>
<div class="line">           <span class="keywordflow">return</span>;</div>
<div class="line"> </div>
<div class="line">   <span class="keywordflow">for</span> (uint32_t i = 0; i &lt; num; i++) {</div>
<div class="line">           <span class="keyword">event</span> = event_tbl[i];</div>
<div class="line">           ... process <span class="stringliteral">&#39;event&#39;</span> ...</div>
<div class="line">   }</div>
<div class="line">}</div>
<div class="ttc" id="aevent__machine__hw__types_8h_html_ace0fe27049350469ff1be8188acfea89ab08afd6a4a38ec98dae5d58f064b8018"><div class="ttname"><a href="../../d0/d07/event__machine__hw__types_8h.html#ace0fe27049350469ff1be8188acfea89ab08afd6a4a38ec98dae5d58f064b8018">EM_EVENT_TYPE_VECTOR</a></div><div class="ttdeci">@ EM_EVENT_TYPE_VECTOR</div><div class="ttdef"><b>Definition:</b> <a href="../../d0/d07/event__machine__hw__types_8h_source.html#l00084">event_machine_hw_types.h:84</a></div></div>
<div class="ttc" id="aevent__machine__types_8h_html_a49fd700da185b0f64834bf967479a992"><div class="ttname"><a href="../../d4/d11/event__machine__types_8h.html#a49fd700da185b0f64834bf967479a992">em_event_type_t</a></div><div class="ttdeci">uint32_t em_event_type_t</div><div class="ttdef"><b>Definition:</b> <a href="../../d4/d11/event__machine__types_8h_source.html#l00085">event_machine_types.h:85</a></div></div>
<div class="ttc" id="agroup__em__event_html_ga1fb6a529eae925f7e443eaba5212c938"><div class="ttname"><a href="../../d5/d33/group__em__event.html#ga1fb6a529eae925f7e443eaba5212c938">em_event_vector_tbl</a></div><div class="ttdeci">uint32_t em_event_vector_tbl(em_event_t vector_event, em_event_t **event_tbl)</div><div class="ttdoc">Get the event vector table from an event of (major) type EM_EVENT_TYPE_VECTOR.</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d32/event__machine__event_8c_source.html#l01779">event_machine_event.c:1779</a></div></div>
<div class="ttc" id="agroup__em__event_html_gaaab47111801094f57ba20c0bc1e8d3b7"><div class="ttname"><a href="../../d5/d33/group__em__event.html#gaaab47111801094f57ba20c0bc1e8d3b7">em_event_get_type</a></div><div class="ttdeci">em_event_type_t em_event_get_type(em_event_t event)</div><div class="ttdef"><b>Definition:</b> <a href="../../da/d32/event__machine__event_8c_source.html#l00970">event_machine_event.c:970</a></div></div>
</div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#gaae1ef08cc9d533f86bd6dd88de2fe603" title="Set the number of event handles stored in a vector.">em_event_vector_size_set()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a56">bench_event.c</a>, <a class="el" href="../../d7/d6f/loop_united_8c-example.html#a19">loop_united.c</a>, and <a class="el" href="../../d9/d33/loop_vectors_8c-example.html#a32">loop_vectors.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l01779">1779</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="gad4f97ba217518d967f8078c56023c4d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad4f97ba217518d967f8078c56023c4d4">&#9670;&nbsp;</a></span>em_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void em_free </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free an event.</p>
<p>The <a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free()</a> function transfers ownership of the event back to the system and the application must not touch the event (or related memory buffers) after calling it.</p>
<p>It is assumed that the implementation can detect the event pool that the event was originally allocated from.</p>
<p>The application must only free events it owns. For example, the sender must not free an event after sending it.</p>
<dl class="section note"><dt>Note</dt><dd>Freeing a vector event (of type EM_EVENT_VECTOR) with this API will also free the events contained in the vector's event-table. To free only the vector event itself, use <a class="el" href="../../d5/d33/group__em__event.html#ga81aeca4166ada444ffd1af91dcfd692d" title="Free the vector event only, not the events it contains.">em_event_vector_free()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event to be freed</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#ga5f0e40f1b0b4892ee16aafe07ba4c90c">em_alloc()</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga824c1dee097236d554918d6702431beb">em_free_multi()</a>, <a class="el" href="../../d5/d33/group__em__event.html#ga81aeca4166ada444ffd1af91dcfd692d" title="Free the vector event only, not the events it contains.">em_event_vector_free()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d9/d8c/api_hooks_8c-example.html#a44">api_hooks.c</a>, <a class="el" href="../../dd/d24/atomic_processing_end_8c-example.html#a35">atomic_processing_end.c</a>, <a class="el" href="../../d5/d1d/bench_event_8c-example.html#a27">bench_event.c</a>, <a class="el" href="../../de/d3a/bench_pool_8c-example.html#a26">bench_pool.c</a>, <a class="el" href="../../d9/d6a/dispatcher_callback_8c-example.html#a41">dispatcher_callback.c</a>, <a class="el" href="../../d9/d32/error_8c-example.html#a36">error.c</a>, <a class="el" href="../../d5/d77/event_group_8c-example.html#a44">event_group.c</a>, <a class="el" href="../../d0/dba/event_group_abort_8c-example.html#a17">event_group_abort.c</a>, <a class="el" href="../../da/daa/event_group_assign_end_8c-example.html#a43">event_group_assign_end.c</a>, <a class="el" href="../../d4/d81/event_group_chaining_8c-example.html#a43">event_group_chaining.c</a>, <a class="el" href="../../d1/d25/fractal_8c-example.html#a28">fractal.c</a>, <a class="el" href="../../d5/dfc/hello_8c-example.html#a40">hello.c</a>, <a class="el" href="../../db/dee/loop_8c-example.html#a29">loop.c</a>, <a class="el" href="../../d3/d14/loop_refs_8c-example.html#a25">loop_refs.c</a>, <a class="el" href="../../d7/d6f/loop_united_8c-example.html#a16">loop_united.c</a>, <a class="el" href="../../d9/d33/loop_vectors_8c-example.html#a42">loop_vectors.c</a>, <a class="el" href="../../d4/d14/ordered_8c-example.html#a31">ordered.c</a>, <a class="el" href="../../d7/dbc/pairs_8c-example.html#a28">pairs.c</a>, <a class="el" href="../../db/d68/pool_perf_8c-example.html#a9">pool_perf.c</a>, <a class="el" href="../../d8/dc3/queue_group_8c-example.html#a41">queue_group.c</a>, <a class="el" href="../../d6/dd3/queue_groups_8c-example.html#a47">queue_groups.c</a>, <a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a61">queue_types_ag.c</a>, <a class="el" href="../../db/dcf/queue_types_local_8c-example.html#a50">queue_types_local.c</a>, <a class="el" href="../../d6/d76/queues_8c-example.html#a30">queues.c</a>, <a class="el" href="../../d0/d69/queues_local_8c-example.html#a31">queues_local.c</a>, <a class="el" href="../../d3/d64/queues_output_8c-example.html#a10">queues_output.c</a>, <a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a26">queues_unscheduled.c</a>, <a class="el" href="../../dd/d3c/scheduling_latency_8c-example.html#a41">scheduling_latency.c</a>, <a class="el" href="../../de/daa/send_multi_8c-example.html#a24">send_multi.c</a>, <a class="el" href="../../d5/dfe/timer_hello_8c-example.html#a59">timer_hello.c</a>, <a class="el" href="../../dd/d10/timer_test_8c-example.html#a60">timer_test.c</a>, <a class="el" href="../../d5/d57/timer_test_periodic_8c-example.html#a83">timer_test_periodic.c</a>, and <a class="el" href="../../d6/d5d/timer_test_ring_8c-example.html#a46">timer_test_ring.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00261">261</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga824c1dee097236d554918d6702431beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga824c1dee097236d554918d6702431beb">&#9670;&nbsp;</a></span>em_free_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void em_free_multi </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Free multiple events.</p>
<p>Similar to <a class="el" href="../../d5/d33/group__em__event.html#gad4f97ba217518d967f8078c56023c4d4">em_free()</a>, but allows freeing of multiple events with one function call. The application must not touch the given events after a call to <a class="el" href="../../d5/d33/group__em__event.html#ga824c1dee097236d554918d6702431beb">em_free_multi()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Freeing vector events (of type EM_EVENT_VECTOR) with this API will also free the events contained in the vectors' event-table. To free only the vector event itself, use <a class="el" href="../../d5/d33/group__em__event.html#ga81aeca4166ada444ffd1af91dcfd692d" title="Free the vector event only, not the events it contains.">em_event_vector_free()</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">events</td><td>Array of events to be freed </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">num</td><td>The number of events in the array 'events[]' </td></tr>
  </table>
  </dd>
</dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d5/d1d/bench_event_8c-example.html#a37">bench_event.c</a>, <a class="el" href="../../d9/d22/loop_multircv_8c-example.html#a33">loop_multircv.c</a>, <a class="el" href="../../d7/d6f/loop_united_8c-example.html#a54">loop_united.c</a>, <a class="el" href="../../db/d68/pool_perf_8c-example.html#a10">pool_perf.c</a>, <a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a36">queues_unscheduled.c</a>, and <a class="el" href="../../de/daa/send_multi_8c-example.html#a34">send_multi.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00370">370</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="gaca4584a01b71429dfbb045342454b464"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaca4584a01b71429dfbb045342454b464">&#9670;&nbsp;</a></span>em_send()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d4/d11/event__machine__types_8h.html#adddd88868f7aa0d32b3e40245eb4ef8f">em_status_t</a> em_send </td>
          <td>(</td>
          <td class="paramtype">em_event_t&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">em_queue_t&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send an event to a queue.</p>
<p>The event must have been allocated with <a class="el" href="../../d5/d33/group__em__event.html#ga5f0e40f1b0b4892ee16aafe07ba4c90c">em_alloc()</a>, or received via an EO receive-function. The sender must not touch the event after calling <a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send()</a> as the ownership has been transferred to the system or possibly to the next receiver. If the return status is <em>not</em> EM_OK, the ownership has not been transferred and the application is still responsible for the event (e.g. may free it).</p>
<p>EM does not currently define guaranteed event delivery, i.e. EM_OK return value only means the event was accepted for delivery. It could still be lost during delivery (e.g. due to a removed queue or system congestion, etc).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event to be sent </td></tr>
    <tr><td class="paramname">queue</td><td>Destination queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>EM_OK if successful (accepted for delivery).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#ga5f0e40f1b0b4892ee16aafe07ba4c90c">em_alloc()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../d9/d8c/api_hooks_8c-example.html#a28">api_hooks.c</a>, <a class="el" href="../../dd/d24/atomic_processing_end_8c-example.html#a27">atomic_processing_end.c</a>, <a class="el" href="../../d5/d1d/bench_event_8c-example.html#a65">bench_event.c</a>, <a class="el" href="../../d9/d6a/dispatcher_callback_8c-example.html#a38">dispatcher_callback.c</a>, <a class="el" href="../../d9/d32/error_8c-example.html#a27">error.c</a>, <a class="el" href="../../d5/d77/event_group_8c-example.html#a30">event_group.c</a>, <a class="el" href="../../d0/dba/event_group_abort_8c-example.html#a37">event_group_abort.c</a>, <a class="el" href="../../da/daa/event_group_assign_end_8c-example.html#a25">event_group_assign_end.c</a>, <a class="el" href="../../d4/d81/event_group_chaining_8c-example.html#a30">event_group_chaining.c</a>, <a class="el" href="../../d1/d25/fractal_8c-example.html#a51">fractal.c</a>, <a class="el" href="../../d5/dfc/hello_8c-example.html#a36">hello.c</a>, <a class="el" href="../../db/dee/loop_8c-example.html#a30">loop.c</a>, <a class="el" href="../../d3/d14/loop_refs_8c-example.html#a31">loop_refs.c</a>, <a class="el" href="../../d7/d6f/loop_united_8c-example.html#a53">loop_united.c</a>, <a class="el" href="../../d9/d33/loop_vectors_8c-example.html#a44">loop_vectors.c</a>, <a class="el" href="../../d4/d14/ordered_8c-example.html#a27">ordered.c</a>, <a class="el" href="../../d7/dbc/pairs_8c-example.html#a29">pairs.c</a>, <a class="el" href="../../db/d68/pool_perf_8c-example.html#a24">pool_perf.c</a>, <a class="el" href="../../d8/dc3/queue_group_8c-example.html#a59">queue_group.c</a>, <a class="el" href="../../d6/dd3/queue_groups_8c-example.html#a46">queue_groups.c</a>, <a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a45">queue_types_ag.c</a>, <a class="el" href="../../db/dcf/queue_types_local_8c-example.html#a40">queue_types_local.c</a>, <a class="el" href="../../d6/d76/queues_8c-example.html#a28">queues.c</a>, <a class="el" href="../../d0/d69/queues_local_8c-example.html#a29">queues_local.c</a>, <a class="el" href="../../d3/d64/queues_output_8c-example.html#a8">queues_output.c</a>, <a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a32">queues_unscheduled.c</a>, <a class="el" href="../../dd/d3c/scheduling_latency_8c-example.html#a40">scheduling_latency.c</a>, <a class="el" href="../../de/daa/send_multi_8c-example.html#a30">send_multi.c</a>, and <a class="el" href="../../d5/d57/timer_test_periodic_8c-example.html#a10">timer_test_periodic.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00661">661</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
<a id="ga272587cb3a55dd241332fd13b6e19054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga272587cb3a55dd241332fd13b6e19054">&#9670;&nbsp;</a></span>em_send_multi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int em_send_multi </td>
          <td>(</td>
          <td class="paramtype">const em_event_t&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">em_queue_t&#160;</td>
          <td class="paramname"><em>queue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send multiple events to a queue.</p>
<p>As em_send, but multiple events can be sent with one call for potential performance gain. The function returns the number of events actually sent. A return value equal to the given 'num' means that all events were sent. A return value less than 'num' means that only the first 'num' events were sent and the rest must be handled by the application.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">events</td><td>Array of events to send </td></tr>
    <tr><td class="paramname">num</td><td>Number of events. The array 'events[]' must contain 'num' entries. </td></tr>
    <tr><td class="paramname">queue</td><td>Destination queue</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of events successfully sent (equal to num if all successful)</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="../../d5/d33/group__em__event.html#gaca4584a01b71429dfbb045342454b464">em_send()</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="../../dd/d24/atomic_processing_end_8c-example.html#a34">atomic_processing_end.c</a>, <a class="el" href="../../d5/d1d/bench_event_8c-example.html#a66">bench_event.c</a>, <a class="el" href="../../d1/d25/fractal_8c-example.html#a44">fractal.c</a>, <a class="el" href="../../db/dee/loop_8c-example.html#a23">loop.c</a>, <a class="el" href="../../d9/d22/loop_multircv_8c-example.html#a27">loop_multircv.c</a>, <a class="el" href="../../d3/d14/loop_refs_8c-example.html#a24">loop_refs.c</a>, <a class="el" href="../../d7/d6f/loop_united_8c-example.html#a10">loop_united.c</a>, <a class="el" href="../../d9/d33/loop_vectors_8c-example.html#a35">loop_vectors.c</a>, <a class="el" href="../../d4/d14/ordered_8c-example.html#a33">ordered.c</a>, <a class="el" href="../../d7/dbc/pairs_8c-example.html#a22">pairs.c</a>, <a class="el" href="../../df/da9/queue_types_ag_8c-example.html#a58">queue_types_ag.c</a>, <a class="el" href="../../db/dcf/queue_types_local_8c-example.html#a48">queue_types_local.c</a>, <a class="el" href="../../d1/ddd/queues_unscheduled_8c-example.html#a35">queues_unscheduled.c</a>, and <a class="el" href="../../de/daa/send_multi_8c-example.html#a33">send_multi.c</a>.</dd>
</dl>

<p class="definition">Definition at line <a class="el" href="../../da/d32/event__machine__event_8c_source.html#l00710">710</a> of file <a class="el" href="../../da/d32/event__machine__event_8c_source.html">event_machine_event.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
  <div id="footer" class="tabs">
   <div class="headertitle"> 
     &copy; 2017 Nokia Networks
   </div>
  </div>
 </body>
</html>
